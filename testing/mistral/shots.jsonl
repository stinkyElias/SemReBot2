{
    "shots": [
        { 
            "domain": "(:types temperature-type ashape surface machine part colour width anorient) (:predicates (temperature ?obj - part ?temp - temperature-type) (busy ?machine - machine) (scheduled ?obj - part) (objscheduled) (surface-condition ?obj - part ?surface-cond - surface) (shape ?obj - part ?shape - ashape) (painted ?obj - part ?colour - colour) (has-hole ?obj - part ?width - width ?orientation - anorient) (has-bit ?machine - machine ?width - width) (can-orient ?machine - machine ?orientation - anorient) (has-paint ?machine - machine ?colour - colour)) ",
            "input": "In the manufacturing facility, you need to set up a task scenario for part P0. This part needs to have specific characteristics and undergo various processing steps. Initially, P0 is cylindrical, polished, painted blue, and cold to the touch. Two machines are involved in this scenario: the immersion painter and the spray painter, both equipped to paint with blue and yellow. Additionally, there are machines like the drill press and punch, capable of orienting parts to the front or back and equipped with bits of size one and two. The goal is to ensure that part P0 is not only painted blue but also has a hole of width two at the front orientation. Organize the setup and conditions to achieve these requirements.",
            "output": "instance P0 part|instance BLUE colour|instance YELLOW colour|instance ONE width|instance TWO width|instance FRONT anorient|instance BACK anorient|predicate HAS-PAINT IMMERSION-PAINTER BLUE|predicate HAS-PAINT SPRAY-PAINTER BLUE|predicate HAS-PAINT IMMERSION-PAINTER YELLOW|predicate HAS-PAINT SPRAY-PAINTER YELLOW|predicate CAN-ORIENT DRILL-PRESS FRONT|predicate CAN-ORIENT PUNCH FRONT|predicate CAN-ORIENT DRILL-PRESS BACK|predicate CAN-ORIENT PUNCH BACK|predicate HAS-BIT DRILL-PRESS ONE|predicate HAS-BIT PUNCH ONE|predicate HAS-BIT DRILL-PRESS TWO|predicate HAS-BIT PUNCH TWO|predicate SHAPE P0 CYLINDRICAL|predicate SURFACE-CONDITION P0 POLISHED|predicate PAINTED P0 BLUE|predicate TEMPERATURE P0 COLD|goal PAINTED P0 BLUE|goal HAS-HOLE P0 TWO FRONT|"
        },
        {
            "domain": "(:types rover waypoint store camera mode lander objective) (:predicates (at ?x - rover ?y - waypoint) (at_lander ?x - lander ?y - waypoint) (can_traverse ?r - rover ?x - waypoint ?y - waypoint) (equipped_for_soil_analysis ?r - rover) (equipped_for_rock_analysis ?r - rover) (equipped_for_imaging ?r - rover) (empty ?s - store) (have_rock_analysis ?r - rover ?w - waypoint) (have_soil_analysis ?r - rover ?w - waypoint) (full ?s - store) (calibrated ?c - camera ?r - rover) (supports ?c - camera ?m - mode) (available ?r - rover) (visible ?w - waypoint ?p - waypoint) (have_image ?r - rover ?o - objective ?m - mode) (communicated_soil_data ?w - waypoint) (communicated_rock_data ?w - waypoint) (communicated_image_data ?o - objective ?m - mode) (at_soil_sample ?w - waypoint) (at_rock_sample ?w - waypoint) (visible_from ?o - objective ?w - waypoint) (store_of ?s - store ?r - rover) (calibration_target ?i - camera ?o - objective) (on_board ?i - camera ?r - rover) (channel_free ?l - lander)) ",
            "input": "You are managing a planetary rover mission. Initially, the rover is at waypoint1 and is equipped for soil and rock analysis and imaging. There are visible paths between waypoints 0, 1, and 2. The goal is to collect soil data at waypoint0, rock data at waypoint1, and image data at waypoint2 using the rover’s camera in low-resolution mode. Ensure that the rover can traverse between these waypoints and that the camera is correctly calibrated with objective0.",
            "output": "instance general Lander|instance colour Mode|instance high_res Mode|instance low_res Mode|instance rover0 Rover|instance rover0store Store|instance waypoint0 Waypoint|instance waypoint1 Waypoint|instance waypoint2 Waypoint|instance camera0 Camera|instance objective0 Objective|instance objective1 Objective|predicate visible waypoint0 waypoint1|predicate visible waypoint1 waypoint0|predicate visible waypoint0 waypoint2|predicate visible waypoint2 waypoint0|predicate visible waypoint2 waypoint1|predicate visible waypoint1 waypoint2|predicate at_soil_sample waypoint0|predicate at_rock_sample waypoint0|predicate at_soil_sample waypoint1|predicate at_rock_sample waypoint1|predicate at_soil_sample waypoint2|predicate at_lander general waypoint2|predicate channel_free general|predicate at rover0 waypoint1|predicate available rover0|predicate store_of rover0store rover0|predicate empty rover0store|predicate equipped_for_soil_analysis rover0|predicate equipped_for_rock_analysis rover0|predicate equipped_for_imaging rover0|predicate can_traverse rover0 waypoint1 waypoint0|predicate can_traverse rover0 waypoint0 waypoint1|predicate can_traverse rover0 waypoint1 waypoint2|predicate can_traverse rover0 waypoint2 waypoint1|predicate on_board camera0 rover0|predicate calibration_target camera0 objective0|predicate supports camera0 low_res|predicate visible_from objective0 waypoint0|predicate visible_from objective0 waypoint1|predicate visible_from objective0 waypoint2|predicate visible_from objective1 waypoint2|goal communicated_soil_data waypoint0|goal communicated_rock_data waypoint1|goal communicated_image_data objective1 low_res|"
        },
        {
            "domain": "(:types child bread-portion content-portion sandwich tray place) (:predicates (at_kitchen_bread ?b - bread-portion) (at_kitchen_content ?c - content-portion) (at_kitchen_sandwich ?s - sandwich) (no_gluten_bread ?b - bread-portion) (no_gluten_content ?c - content-portion) (ontray ?s - sandwich ?t - tray) (no_gluten_sandwich ?s - sandwich) (allergic_gluten ?c - child) (not_allergic_gluten ?c - child) (served ?c - child) (waiting ?c - child ?p - place) (at ?t - tray ?p - place) (notexist ?s - sandwich) ) ",
            "input": "In the kitchen, there are three portions each of bread and content to make sandwiches, with bread1 being gluten-free and content3 also gluten-free. There are two trays in the kitchen ready to use. Child1, who is allergic to gluten, is waiting at table2, while child2 and child3, who are not allergic to gluten, are waiting at table1 and table2, respectively. You need to prepare sandwiches, considering the dietary restrictions, and serve them to the children at their respective tables. There are four sandwiches to be made and named from sandw1 to sandw4, which currently do not exist.",
            "output": "instance child1 child|instance child2 child|instance child3 child|instance bread1 bread-portion|instance bread2 bread-portion|instance bread3 bread-portion|instance content1 content-portion|instance content2 content-portion|instance content3 content-portion|instance tray1 tray|instance tray2 tray|instance table1 place|instance table2 place|instance table3 place|instance sandw1 sandwich|instance sandw2 sandwich|instance sandw3 sandwich|instance sandw4 sandwich|instance kitchen place|predicate at tray1 kitchen|predicate at tray2 kitchen|predicate at_kitchen_bread bread1|predicate at_kitchen_bread bread2|predicate at_kitchen_bread bread3|predicate at_kitchen_content content1|predicate at_kitchen_content content2|predicate at_kitchen_content content3|predicate no_gluten_bread bread1|predicate no_gluten_content content3|predicate allergic_gluten child1|predicate not_allergic_gluten child3|predicate not_allergic_gluten child2|predicate waiting child1 table2|predicate waiting child2 table1|predicate waiting child3 table2|predicate notexist sandw1|predicate notexist sandw2|predicate notexist sandw3|predicate notexist sandw4|goal served child1|goal served child2|goal served child3|"
        },
        { 
            "domain": "(:types location locatable - object man nut spanner - locatable ) (:predicates (at ?m - locatable ?l - location) (carrying ?m - man ?s - spanner) (useable ?s - spanner) (link ?l1 - location ?l2 - location) (tightened ?n - nut) (loose ?n - nut)) ",
            "input": "Bob is in a shed and needs to tighten nuts at the gate using spanners located in a different location. There are three spanners available, all usable. Two nuts need tightening at the gate. The locations are connected in such a way that Bob can access the spanners from the shed. Your goal is to ensure that both nuts are tightened effectively.",
            "output": "instance bob man|instance spanner1 spanner|instance spanner2 spanner|instance spanner3 spanner|instance nut1 nut|instance nut2 nut|instance location1 location|instance shed location|instance gate location|predicate at bob shed|predicate at spanner1 location1|predicate useable spanner1|predicate at spanner2 location1|predicate useable spanner2|predicate at spanner3 location1|predicate useable spanner3|predicate loose nut1|predicate at nut1 gate|predicate loose nut2|predicate at nut2 gate|predicate link shed location1|predicate link location1 gate|goal tightened nut1|goal tightened nut2|"
        },
        {
            "domain": "(:types place locatable - object depot distributor - place truck hoist surface - locatable pallet crate - surface) (:predicates (at ?x - locatable ?y - place) (on ?x - crate ?y - surface) (in ?x - crate ?y - truck) (lifting ?x - hoist ?y - crate) (available ?x - hoist) (clear ?x - surface)) ",
            "input": "You are managing a logistics hub involving multiple depots and distributors. The facilities include three depots and two distributors. You are equipped with one truck, five pallets, five crates, and five hoists. The truck is currently at Distributor0. Each hoist is stationed at a different location: Hoist0 at Depot0, Hoist1 at Depot1, Hoist2 at Depot2, Hoist3 at Distributor0, and Hoist4 at Distributor1, and all are available for operations. Your crates and pallets are positioned as follows: Crate0 on Pallet4 at Distributor1, Crate1 on Pallet0 at Depot0, Crate2 on top of Crate1 at Depot0, Crate3 on Crate0 at Distributor1, and Crate4 on Pallet2 at Depot2. Pallets at Depot1 and Distributors are clear of crates. The goal is to reorganize these crates to ensure that Crate0 ends up on Pallet4, Crate1 on Pallet2, Crate2 on Pallet0, Crate3 on Pallet3, and Crate4 on Crate0. Plan and execute the movements and lifting operations efficiently to meet these objectives.",
            "output": "instance depot0 Depot|instance depot1 Depot|instance depot2 Depot|instance distributor0 Distributor|instance distributor1 Distributor|instance truck0 Truck|instance pallet0 Pallet|instance pallet1 Pallet|instance pallet2 Pallet|instance pallet3 Pallet|instance pallet4 Pallet|instance crate0 Crate|instance crate1 Crate|instance crate2 Crate|instance crate3 Crate|instance crate4 Crate|instance hoist0 Hoist|instance hoist1 Hoist|instance hoist2 Hoist|instance hoist3 Hoist|instance hoist4 Hoist|predicate at pallet0 depot0|predicate clear crate2|predicate at pallet1 depot1|predicate clear pallet1|predicate at pallet2 depot2|predicate clear crate4|predicate at pallet3 distributor0|predicate clear pallet3|predicate at pallet4 distributor1|predicate clear crate3|predicate at truck0 distributor0|predicate at hoist0 depot0|predicate available hoist0|predicate at hoist1 depot1|predicate available hoist1|predicate at hoist2 depot2|predicate available hoist2|predicate at hoist3 distributor0|predicate available hoist3|predicate at hoist4 distributor1|predicate available hoist4|predicate at crate0 distributor1|predicate on crate0 pallet4|predicate at crate1 depot0|predicate on crate1 pallet0|predicate at crate2 depot0|predicate on crate2 crate1|predicate at crate3 distributor1|predicate on crate3 crate0|predicate at crate4 depot2|predicate on crate4 pallet2|goal on crate0 pallet4|goal on crate1 pallet2|goal on crate2 pallet0|goal on crate3 pallet3|goal on crate4 crate0|"
        },
        {
            "domain": "(:types passenger - object going_up going_down vip going_nonstop attendant never_alone conflict_A conflict_B - passenger floor - object ) (:predicates (origin ?person - passenger ?floor - floor) ;; entry of ?person is ?floor ;; inertia (destin ?person - passenger ?floor - floor) ;; exit of ?person is ?floor ;; inertia (no-access ?person - passenger ?floor - floor) ;; access limitation of ?person on ?floor (above ?floor1 - floor ?floor2 - floor) ;; ?floor2 is located above of ?floor1 (boarded ?person - passenger) ;; true if ?person has boarded the lift (served ?person - passenger) ;; true if ?person has alighted as her destination (lift-at ?floor - floor) ;; current position of the lift is at ?floor ) ",
            "input": "In this elevator simulation, you have two passengers, p0 and p1, and three floors, f0, f1, and f2. The floors are arranged such that f0 is the lowest, f1 is above f0, and f2 is the highest. Passenger p0 starts on the top floor, f2, and needs to get to f1. Passenger p1 starts on the bottom floor, f0, and also needs to get to f1. The elevator is currently at the bottom floor, f0. Your goal is to ensure that both passengers are transported to their destinations efficiently. The elevator should travel between floors following the designated order, and both passengers must be served, meaning they reach their designated floors.",
            "output": "instance p0 passenger|instance p1 passenger|instance f0 floor|instance f1 floor|instance f2 floor|predicate above f0 f1|predicate above f0 f2|predicate above f1 f2|predicate origin p0 f2|predicate destin p0 f1|predicate origin p1 f0|predicate destin p1 f1|predicate lift-at f0|goal served p0|goal served p1|"
        },
        {
            "domain": "(:types car junction garage road ) (:predicates (same_line ?xy - junction ?xy2 - junction) ;; junctions in line (row) (diagonal ?x - junction ?y - junction ) ;; junctions in diagonal (on the map) (at_car_jun ?c - car ?x - junction) ;; a car is at the junction (at_car_road ?c - car ?x - road) ;; a car is in a road (starting ?c - car ?x - garage) ;; a car is in its initial position (arrived ?c - car ?x - junction) ;; a car arrived at destination (road_connect ?r1 - road ?xy - junction ?xy2 - junction) ;; there is a road that connects 2 junctions (clear ?xy - junction ) ;; the junction is clear (in_place ?x - road);; the road has been put in place (at_garage ?g - garage ?xy - junction ) ;; position of the starting garage ) ",
            "input": "Begin with a grid layout of junctions from junction0-0 to junction2-2, forming a 3x3 matrix. Two cars, car0 and car1, initially start at garage0, located at junction0-1. The city allows for the construction and demolition of roads to facilitate car movement. Your objective is to guide both cars to their destination at junction2-1. You can build straight or diagonal roads between junctions, but each road's construction or demolition incurs specific costs. Ensure that the cars reach their destination with minimal total costs, leveraging the ability to build and remove roads as needed.",
            "output": "instance junction0-0 junction|instance junction0-1 junction|instance junction0-2 junction|instance junction1-0 junction|instance junction1-1 junction|instance junction1-2 junction|instance junction2-0 junction|instance junction2-1 junction|instance junction2-2 junction|instance car0 car|instance car1 car|instance garage0 garage|instance road0 road|instance road1 road|instance road2 road|instance road3 road|instance road4 road|predicate clear junction0-0|predicate clear junction0-1|predicate clear junction0-2|predicate clear junction1-0|predicate clear junction1-1|predicate clear junction1-2|predicate clear junction2-0|predicate clear junction2-1|predicate clear junction2-2|predicate same_line junction0-0 junction0-1|predicate same_line junction0-1 junction0-0|predicate same_line junction0-1 junction0-2|predicate same_line junction0-2 junction0-1|predicate same_line junction1-0 junction1-1|predicate same_line junction1-1 junction1-0|predicate same_line junction1-1 junction1-2|predicate same_line junction1-2 junction1-1|predicate same_line junction2-0 junction2-1|predicate same_line junction2-1 junction2-0|predicate same_line junction2-1 junction2-2|predicate same_line junction2-2 junction2-1|predicate same_line junction0-0 junction1-0|predicate same_line junction1-0 junction0-0|predicate same_line junction1-0 junction2-0|predicate same_line junction2-0 junction1-0|predicate same_line junction0-1 junction1-1|predicate same_line junction1-1 junction0-1|predicate same_line junction1-1 junction2-1|predicate same_line junction2-1 junction1-1|predicate same_line junction0-2 junction1-2|predicate same_line junction1-2 junction0-2|predicate same_line junction1-2 junction2-2|predicate same_line junction2-2 junction1-2|predicate diagonal junction0-0 junction1-1|predicate diagonal junction1-1 junction0-0|predicate diagonal junction0-1 junction1-0|predicate diagonal junction1-0 junction0-1|predicate diagonal junction0-1 junction1-2|predicate diagonal junction1-2 junction0-1|predicate diagonal junction0-2 junction1-1|predicate diagonal junction1-1 junction0-2|predicate diagonal junction1-0 junction2-1|predicate diagonal junction2-1 junction1-0|predicate diagonal junction1-1 junction2-0|predicate diagonal junction2-0 junction1-1|predicate diagonal junction1-1 junction2-2|predicate diagonal junction2-2 junction1-1|predicate diagonal junction1-2 junction2-1|predicate diagonal junction2-1 junction1-2|predicate at_garage garage0 junction0-1|predicate starting car0 garage0|predicate starting car1 garage0|cost total-cost 0|goal arrived car0 junction2-1|goal arrived car1 junction2-1|"
        },
        {
            "domain": "(:types hoist surface place area - object container depot - place storearea transitarea - area area crate - surface) (:predicates (clear ?s - storearea) (in ?x - (either storearea crate) ?p - place) (available ?h - hoist) (lifting ?h - hoist ?c - crate) (at ?h - hoist ?a - area) (on ?c - crate ?s - storearea) (connected ?a1 ?a2 - area) (compatible ?c1 ?c2 - crate)) ",
            "input": "Manage a storage facility encompassing a main depot (Depot48) divided into nine storage areas, a transit area (LoadArea), and multiple containers. The depot areas are named sequentially from depot48-1-1 to depot48-3-3. You have five hoists (Hoist0 to Hoist4), strategically located for optimal access to various sections of the depot. Each hoist is currently available. Five crates, from Crate0 to Crate4, are distributed across different containers within the storage areas, specifically positioned in containers container-0-0 to container-0-4. The goal is to rearrange these crates so each one is stored within Depot48's designated areas by utilizing the hoists to lift and move the crates as required. Establish and maintain clear paths between areas for efficient movement, ensuring all crates end up in the correct sections of the depot while maintaining clarity in the transit and storage areas.",
            "output": "instance depot48-1-1 storearea|instance depot48-1-2 storearea|instance depot48-1-3 storearea|instance depot48-2-1 storearea|instance depot48-2-2 storearea|instance depot48-2-3 storearea|instance depot48-3-1 storearea|instance depot48-3-2 storearea|instance depot48-3-3 storearea|instance container-0-0 storearea|instance container-0-1 storearea|instance container-0-2 storearea|instance container-0-3 storearea|instance container-0-4 storearea|instance hoist0 hoist|instance hoist1 hoist|instance hoist2 hoist|instance crate0 crate|instance crate1 crate|instance crate2 crate|instance crate3 crate|instance crate4 crate|instance container0 container|instance depot48 depot|instance loadarea transitarea|predicate connected depot48-1-1 depot48-2-1|predicate connected depot48-1-1 depot48-1-2|predicate connected depot48-1-2 depot48-2-2|predicate connected depot48-1-2 depot48-1-3|predicate connected depot48-1-2 depot48-1-1|predicate connected depot48-1-3 depot48-2-3|predicate connected depot48-1-3 depot48-1-2|predicate connected depot48-2-1 depot48-1-1|predicate connected depot48-2-1 depot48-3-1|predicate connected depot48-2-1 depot48-2-2|predicate connected depot48-2-2 depot48-1-2|predicate connected depot48-2-2 depot48-3-2|predicate connected depot48-2-2 depot48-2-3|predicate connected depot48-2-2 depot48-2-1|predicate connected depot48-2-3 depot48-1-3|predicate connected depot48-2-3 depot48-3-3|predicate connected depot48-2-3 depot48-2-2|predicate connected depot48-3-1 depot48-2-1|predicate connected depot48-3-1 depot48-3-2|predicate connected depot48-3-2 depot48-2-2|predicate connected depot48-3-2 depot48-3-3|predicate connected depot48-3-2 depot48-3-1|predicate connected depot48-3-3 depot48-2-3|predicate connected depot48-3-3 depot48-3-2|predicate in depot48-1-1 depot48|predicate in depot48-1-2 depot48|predicate in depot48-1-3 depot48|predicate in depot48-2-1 depot48|predicate in depot48-2-2 depot48|predicate in depot48-2-3 depot48|predicate in depot48-3-1 depot48|predicate in depot48-3-2 depot48|predicate in depot48-3-3 depot48|predicate on crate0 container-0-0|predicate on crate1 container-0-1|predicate on crate2 container-0-2|predicate on crate3 container-0-3|predicate on crate4 container-0-4|predicate in crate0 container0|predicate in crate1 container0|predicate in crate2 container0|predicate in crate3 container0|predicate in crate4 container0|predicate in container-0-0 container0|predicate in container-0-1 container0|predicate in container-0-2 container0|predicate in container-0-3 container0|predicate in container-0-4 container0|predicate connected loadarea container-0-0|predicate connected container-0-0 loadarea|predicate connected loadarea container-0-1|predicate connected container-0-1 loadarea|predicate connected loadarea container-0-2|predicate connected container-0-2 loadarea|predicate connected loadarea container-0-3|predicate connected container-0-3 loadarea|predicate connected loadarea container-0-4|predicate connected container-0-4 loadarea|predicate connected depot48-3-2 loadarea|predicate connected loadarea depot48-3-2|predicate clear depot48-3-1|predicate clear depot48-1-2|predicate clear depot48-1-3|predicate clear depot48-2-1|predicate clear depot48-2-2|predicate clear depot48-2-3|predicate at hoist0 depot48-3-3|predicate available hoist0|predicate at hoist1 depot48-3-2|predicate available hoist1|predicate at hoist2 depot48-1-1|predicate available hoist2|goal in crate0 depot48|goal in crate1 depot48|goal in crate2 depot48|goal in crate3 depot48|goal in crate4 depot48|"
        },
        {
            "domain": "(:types car curb) (:predicates (at-curb ?car - car) (at-curb-num ?car - car ?curb - curb) (behind-car ?car ?front-car - car) (car-clear ?car - car) (curb-clear ?curb - curb) ) ",
            "input": "Organize a parking situation where twelve cars, labeled from car_00 to car_11, need to be strategically parked along seven curbs, labeled from curb_0 to curb_6. Each car must be parked at a specific curb and some cars need to be positioned directly behind others. For example, car_02 is already parked at curb_0 and needs to remain there. Car_05 should be positioned directly behind car_02 and must be clear of any obstructions. Similarly, arrange for car_10 to park at curb_1, with car_11 behind it. Continue arranging the cars so that each follows the specific conditions of being clear or parked behind another car, as required. Additionally, ensure that curb_6 is kept completely clear of any vehicles. The goal is to have all cars parked in a new specified order with specific cars parked behind others to achieve an optimal parking configuration.",
            "output": "instance car_00 car|instance car_01 car|instance car_02 car|instance car_03 car|instance car_04 car|instance car_05 car|instance car_06 car|instance car_07 car|instance car_08 car|instance car_09 car|instance car_10 car|instance car_11 car|instance curb_0 curb|instance curb_1 curb|instance curb_2 curb|instance curb_3 curb|instance curb_4 curb|instance curb_5 curb|instance curb_6 curb|predicate at-curb car_02|predicate at-curb-num car_02 curb_0|predicate behind-car car_05 car_02|predicate car-clear car_05|predicate at-curb car_10|predicate at-curb-num car_10 curb_1|predicate behind-car car_11 car_10|predicate car-clear car_11|predicate at-curb car_07|predicate at-curb-num car_07 curb_2|predicate behind-car car_03 car_07|predicate car-clear car_03|predicate at-curb car_06|predicate at-curb-num car_06 curb_3|predicate behind-car car_00 car_06|predicate car-clear car_00|predicate at-curb car_09|predicate at-curb-num car_09 curb_4|predicate behind-car car_04 car_09|predicate car-clear car_04|predicate at-curb car_01|predicate at-curb-num car_01 curb_5|predicate behind-car car_08 car_01|predicate car-clear car_08|predicate curb-clear curb_6|goal at-curb-num car_00 curb_0|goal behind-car car_07 car_00|goal at-curb-num car_01 curb_1|goal behind-car car_08 car_01|goal at-curb-num car_02 curb_2|goal behind-car car_09 car_02|goal at-curb-num car_03 curb_3|goal behind-car car_10 car_03|goal at-curb-num car_04 curb_4|goal behind-car car_11 car_04|goal at-curb-num car_05 curb_5|goal at-curb-num car_06 curb_6|"
        },
        {
            "domain": "(:types portable location) (:predicates (at ?y - portable ?x - location) (in ?x - portable) (is-at ?x - location)) ",
            "input": "Transport all the four objects to their respective location: first object to location 3, second object to location 0, third object to location 1 and fourth object at location 2. Also, go to location 1 afterwards. The four objects are now at location 3, location 1, location 2 and location 0 respectively. We are in location 4.",
            "output": "instance l0 location|instance l1 location|instance l2 location|instance l3 location|instance l4 location|instance o0 portable|instance o1 portable|instance o2 portable|instance o3 portable|predicate at o0 l3|predicate at o1 l1|predicate at o2 l2|predicate at o3 l0|predicate is-at l4|goal at o0 l3|goal at o1 l0|goal at o2 l1|goal at o3 l2|goal is-at l1|"
        },
        {
            "domain": "(:types aircraft person city flevel - object) (:predicates (at ?x - (either person aircraft) ?c - city) (in ?p - person ?a - aircraft) (fuel-level ?a - aircraft ?l - flevel) (next ?l1 ?l2 - flevel)) ",
            "input": "Set up a transportation scenario involving three aircrafts and four persons distributed between two cities, city0 and city1. Place plane1 and plane2 at city0, both starting with the lowest fuel level, fl0. Have plane3 start at city1, also with the lowest fuel level, fl0. Position person1 and person3 in city0, and person2 in city1, with person4 also starting in city0. Manage a series of fuel levels from fl0 to fl6 where each level is a successive increment from the previous one. Your task is to reposition person1, person2, and person3 to city0, and person4 to city1, aligning with specified fuel level adjustments for the planes as necessary. Each person’s and aircraft's current and final city should be clearly logged, ensuring all movements and transitions are according to the given sequential fuel levels.",
            "output": "instance plane1 plane|instance plane2 plane|instance plane3 plane|instance person1 person|instance person2 person|instance person3 person|instance person4 person|instance city0 city|instance city1 city|instance fl0 fuel_level|instance fl1 fuel_level|instance fl2 fuel_level|instance fl3 fuel_level|instance fl4 fuel_level|instance fl5 fuel_level|instance fl6 fuel_level|predicate at plane1 city0|predicate aircraft plane1|predicate fuel-level plane1 fl0|predicate at plane2 city0|predicate aircraft plane2|predicate fuel-level plane2 fl0|predicate at plane3 city1|predicate aircraft plane3|predicate fuel-level plane3 fl0|predicate at person1 city0|predicate person person1|predicate at person2 city1|predicate person person2|predicate at person3 city0|predicate person person3|predicate at person4 city0|predicate person person4|predicate city city0|predicate city city1|predicate next fl0 fl1|predicate next fl1 fl2|predicate next fl2 fl3|predicate next fl3 fl4|predicate next fl4 fl5|predicate next fl5 fl6|predicate flevel fl0|predicate flevel fl1|predicate flevel fl2|predicate flevel fl3|predicate flevel fl4|predicate flevel fl5|predicate flevel fl6|goal at person1 city0|goal at person2 city0|goal at person3 city0|goal at person4 city1|"
        },
        {
            "domain": "(:types screw backplane compressor fridge) (:predicates (screwed ?s - screw) (attached ?c - compressor ?f - fridge) (fits ?s - screw ?c -compressor) (fridge-on ?f - fridge)) ",
            "input": "Prepare an assembly scenario for two refrigerators using different compressors and screws. There are two fridges, labeled f0 and f1, each requiring a specific compressor attachment. Each fridge will have two compressor options, c0-0 and c0-1 for f0, and c1-0 and c1-1 for f1. Equip each compressor with three screws, ensuring all screws are compatible with both compressors they might be used with. All screws for the first fridge are from series s0-0 to s0-2 and for the second fridge from s1-0 to s1-2. Ensure that the screws fit the compressors as required and that they are indeed screwed in. Both fridges should be powered on in the end. Your goal is to correctly attach compressor c0-1 to fridge f0 and compressor c1-1 to fridge f1, ensuring both fridges remain powered on.",
            "output": "instance s0-0 screw|instance s0-1 screw|instance s0-2 screw|instance s1-0 screw|instance s1-1 screw|instance s1-2 screw|instance c0-0 compressor|instance c0-1 compressor|instance c1-0 compressor|instance c1-1 compressor|instance f0 fridge|instance f1 fridge|predicate fridge-on f0|predicate attached c0-0 f0|predicate fridge-on f1|predicate attached c1-0 f1|predicate fits s0-0 c0-0|predicate fits s0-0 c0-1|predicate screwed s0-0|predicate fits s0-1 c0-0|predicate fits s0-1 c0-1|predicate screwed s0-1|predicate fits s0-2 c0-0|predicate fits s0-2 c0-1|predicate screwed s0-2|predicate fits s1-0 c1-0|predicate fits s1-0 c1-1|predicate screwed s1-0|predicate fits s1-1 c1-0|predicate fits s1-1 c1-1|predicate screwed s1-1|predicate fits s1-2 c1-0|predicate fits s1-2 c1-1|predicate screwed s1-2|goal attached c0-1 f0|goal fridge-on f0|goal attached c1-1 f1|goal fridge-on f1|"
        },
        {
            "domain": "(:types place - object) (:predicates (connected ?x ?y - place) (at-robot ?x - place) (visited ?x - place) ) ",
            "input": "Initialize a grid navigation task where a robot is located at a specific place designated as loc-x1-y1. This location should be the starting point for the robot. Mark this place as visited immediately upon the robot's arrival. The goal for the robot is to ensure that it has visited loc-x1-y1, confirming its presence at this starting location.",
            "output": "instance loc-x1-y1 place|predicate at-robot loc-x1-y1|predicate visited loc-x1-y1|goal visited loc-x1-y1|"
        },
        {
            "domain": "(:types car tent person couple place ) (:predicates (at_tent ?x1 - tent ?x2 - place) (at_person ?x1 - person ?x2 - place) (at_car ?x1 - car ?x2 - place) (partners ?x1 - couple ?x2 - person ?x3 - person) (up ?x1 - tent) (down ?x1 - tent) (walked ?x1 - couple ?x2 - place) (next ?x1 - place ?x2 - place) ) ",
            "input": "Consider a scenario with three cars (car0, car1, car2), two tents (tent0, tent1), two couples (couple0, couple1), and four places (place0 to place3). The people are guy0, girl0 for couple0, and guy1, girl1 for couple1. Initially, couple0 and couple1 are partners as guy0 is with girl0 and guy1 is with girl1, respectively. Both couples start at place0, where tent0 is set up and up, while tent1 is also at place0 but is down. All three cars are at place0. The places are connected sequentially from place0 to place3. The goal is for both couples to have walked to place3.",
            "output": "instance car0 car|instance car1 car|instance car2 car|instance tent0 tent|instance tent1 tent|instance couple0 couple|instance couple1 couple|instance place0 place|instance place1 place|instance place2 place|instance place3 place|instance guy0 person|instance girl0 person|instance guy1 person|instance girl1 person|predicate partners couple0 guy0 girl0|predicate at_person guy0 place0|predicate at_person girl0 place0|predicate walked couple0 place0|predicate at_tent tent0 place0|predicate up tent0|predicate partners couple1 guy1 girl1|predicate at_person guy1 place0|predicate at_person girl1 place0|predicate walked couple1 place0|predicate at_tent tent1 place0|predicate down tent1|predicate at_car car0 place0|predicate at_car car1 place0|predicate at_car car2 place0|predicate next place0 place1|predicate next place1 place2|predicate next place2 place3|goal walked couple0 place3|goal walked couple1 place3|"
        },
        {
            "domain": "(:types place locatable level - object depot market - place truck goods - locatable) (:predicates (loaded ?g - goods ?t - truck ?l - level) (ready-to-load ?g - goods ?m - market ?l - level) (stored ?g - goods ?l - level) (on-sale ?g - goods ?m - market ?l - level) (next ?l1 ?l2 - level) (at ?t - truck ?p - place) (connected ?p1 ?p2 - place)) ",
            "input": "Initiate a logistics operation involving one depot and two distributors. You have at your disposal two trucks, three hoists,five pallets and two crates. Pallet one and four are at the depot, pallet two and five is a the first distributor while pallet three is at the second distributor. Pallets three, four and five and crates are cleared at the beginning. The two trucks start at the first distributor. All hoists are available and the three of them are distributed around the depot and the two distributors. First crate is at the depot placed on the first pallet. The second crate is at the first distributor and placed on the second pallet. Your task is to ensure that the first crate ends up on pallet four at the depot, and that the second crate end up on the fifth pallet, also initially at Distributor0. Utilize the trucks and hoists available at each location to move the crates efficiently, respecting the constraint that crates must be lifted from their current pallets before being moved or loaded into trucks.",
            "output": "instance depot0 depot|instance distributor0 distributor|instance distributor1 distributor|instance truck0 truck|instance truck1 truck|instance pallet0 pallet|instance pallet1 pallet|instance pallet2 pallet|instance pallet3 pallet|instance pallet4 pallet|instance crate0 crate|instance crate1 crate|instance hoist0 hoist|instance hoist1 hoist|instance hoist2 hoist|predicate at pallet0 depot0|predicate clear crate0|predicate at pallet1 distributor0|predicate clear crate1|predicate at pallet2 distributor1|predicate clear pallet2|predicate at pallet3 depot0|predicate clear pallet3|predicate at pallet4 distributor0|predicate clear pallet4|predicate at truck0 distributor0|predicate at truck1 distributor0|predicate at hoist0 depot0|predicate available hoist0|predicate at hoist1 distributor0|predicate available hoist1|predicate at hoist2 distributor1|predicate available hoist2|predicate at crate0 depot0|predicate on crate0 pallet0|predicate at crate1 distributor0|predicate on crate1 pallet1|goal on crate0 pallet3|goal on crate1 pallet4|"
        },
        {
            "domain": "(:types location target locatable - object vehicle package - locatable capacity-number - object ) (:predicates (road ?l1 ?l2 - location) (at ?x - locatable ?v - location) (in ?x - package ?v - vehicle) (capacity ?v - vehicle ?s1 - capacity-number) (capacity-predecessor ?s1 ?s2 - capacity-number) ) ",
            "input": "Organize a delivery scenario involving three city locations, labeled city-loc-1, city-loc-2, and city-loc-3. Two trucks are available for transporting packages, with truck-1 starting at city-loc-1 and truck-2 at city-loc-3. Each truck has a specific carrying capacity, managed through capacity levels ranging from capacity-0 to capacity-4, arranged in a predecessor relationship for load management. Two packages need delivery: package-1 starts at city-loc-1 and must be delivered to city-loc-3, and package-2 starts at city-loc-2 and also needs to end at city-loc-3. Establish roads between these locations with specific lengths to manage transit costs effectively. The objective is to ensure both packages are delivered to city-loc-3 efficiently.",
            "output": "instance city-loc-1 location|instance city-loc-2 location|instance city-loc-3 location|instance truck-1 vehicle|instance truck-2 vehicle|instance package-1 package|instance package-2 package|instance capacity-0 capacity-number|instance capacity-1 capacity-number|instance capacity-2 capacity-number|instance capacity-3 capacity-number|instance capacity-4 capacity-number|predicate total-cost 0|predicate capacity-predecessor capacity-0 capacity-1|predicate capacity-predecessor capacity-1 capacity-2|predicate capacity-predecessor capacity-2 capacity-3|predicate capacity-predecessor capacity-3 capacity-4|predicate road city-loc-3 city-loc-1|predicate road-length city-loc-3 city-loc-1 53|predicate road city-loc-1 city-loc-3|predicate road-length city-loc-1 city-loc-3 53|predicate road city-loc-3 city-loc-2|predicate road-length city-loc-3 city-loc-2 38|predicate road city-loc-2 city-loc-3|predicate road-length city-loc-2 city-loc-3 38|predicate at package-1 city-loc-1|predicate at package-2 city-loc-2|predicate at truck-1 city-loc-1|predicate capacity truck-1 capacity-3|predicate at truck-2 city-loc-3|predicate capacity truck-2 capacity-2|goal at package-1 city-loc-3|goal at package-2 city-loc-3|"
        },
        {
            "domain": "(:types obj - object tool wheel nut - obj container hub - object) (:predicates (open ?x) (closed ?x) (have ?x) (in ?x ?y) (loose ?x ?y) (tight ?x ?y) (unlocked ?x) (on-ground ?x) (not-on-ground ?x) (inflated ?x) (not-inflated ?x) (fastened ?x) (unfastened ?x) (free ?x) (on ?x ?y) (intact ?x)) ",
            "input": "Prepare a scenario to replace a flat tire using various tools and components. You have a toolbox containing essential items: a wrench, a jack, and a pump. These tools are currently inside a boot, which is unlocked and closed. Additionally, there's a wheel, labeled r1, that's not inflated and is inside the boot, and another wheel, w1, is correctly mounted on the hub the-hub1, which is on the ground, tightly fastened, and has the nuts securely in place. The task is to swap the flat wheel r1 with the wheel w1, ensure r1 is inflated and fastened on the hub, and then place w1 and all tools back into the boot, securing it afterward.",
            "output": "instance wrench tool|instance jack tool|instance pump tool|instance the-hub1 hub|instance nuts1 nut|instance boot container|instance r1 wheel|instance w1 wheel|predicate in jack boot|predicate in pump boot|predicate in wrench boot|predicate unlocked boot|predicate closed boot|predicate intact r1|predicate in r1 boot|predicate not-inflated r1|predicate on w1 the-hub1|predicate on-ground the-hub1|predicate tight nuts1 the-hub1|predicate fastened the-hub1|goal on r1 the-hub1|goal inflated r1|goal tight nuts1 the-hub1|goal in w1 boot|goal in wrench boot|goal in jack boot|goal in pump boot|goal closed boot|"
        },
        {
            "domain": "(:types plane day airport) (:predicates (done ?p - plane) (today ?d - day) (at ?p - plane ?d - day ?c - airport) (next ?d - day ?d2 - day) ) ",
            "input": "Organize a detailed scheduling plan for 30 planes over 11 days at two major airports, FRA and BER. For the next 11 days, starting from today, assign these planes to various airports based on a predetermined schedule. Planes need to be moved between these airports on specific days, with certain planes arriving and departing multiple times throughout this period. Each plane's goal is to complete all its scheduled movements by the end of the 11-day period without any delays or issues. Ensure that planes such as ap1 through ap30 are tracked daily, marking them as 'done' once they have successfully completed all their scheduled transfers between the airports by the designated days.",
            "output": "instance d1 day|instance d2 day|instance d3 day|instance d4 day|instance d5 day|instance d6 day|instance d7 day|instance d8 day|instance d9 day|instance d10 day|instance d11 day|instance FRA airport|instance BER airport|instance ap1 plane|instance ap2 plane|instance ap3 plane|instance ap4 plane|instance ap5 plane|instance ap6 plane|instance ap7 plane|instance ap8 plane|instance ap9 plane|instance ap10 plane|instance ap11 plane|instance ap12 plane|instance ap13 plane|instance ap14 plane|instance ap15 plane|instance ap16 plane|instance ap17 plane|instance ap18 plane|instance ap19 plane|instance ap20 plane|instance ap21 plane|instance ap22 plane|instance ap23 plane|instance ap24 plane|instance ap25 plane|instance ap26 plane|instance ap27 plane|instance ap28 plane|instance ap29 plane|instance ap30 plane|predicate today d1|predicate today d2|predicate today d3|predicate today d4|predicate today d5|predicate today d6|predicate today d7|predicate today d8|predicate today d9|predicate today d10|predicate at ap1 d8 FRA|predicate at ap2 d5 BER|predicate at ap3 d4 BER|predicate at ap3 d7 BER|predicate at ap6 d8 FRA|predicate at ap7 d1 FRA|predicate at ap7 d8 FRA|predicate at ap8 d6 BER|predicate at ap9 d5 FRA|predicate at ap9 d10 FRA|predicate at ap11 d1 BER|predicate at ap12 d2 FRA|predicate at ap12 d2 BER|predicate at ap13 d10 BER|predicate at ap14 d8 FRA|predicate at ap14 d3 BER|predicate at ap15 d4 BER|predicate at ap15 d10 BER|predicate at ap16 d5 BER|predicate at ap16 d6 BER|predicate at ap17 d2 BER|predicate at ap18 d10 BER|predicate at ap19 d10 FRA|predicate at ap22 d2 FRA|predicate at ap23 d2 FRA|predicate at ap23 d9 BER|predicate at ap25 d4 FRA|predicate at ap25 d10 BER|predicate at ap26 d7 FRA|predicate at ap27 d7 FRA|predicate at ap27 d6 BER|predicate at ap28 d9 FRA|predicate at ap29 d4 BER|goal done ap1|goal done ap2|goal done ap3|goal done ap4|goal done ap5|goal done ap6|goal done ap7|goal done ap8|goal done ap9|goal done ap10|goal done ap11|goal done ap12|goal done ap13|goal done ap14|goal done ap15|goal done ap16|goal done ap17|goal done ap18|goal done ap19|goal done ap20|goal done ap21|goal done ap22|goal done ap23|goal done ap24|goal done ap25|goal done ap26|goal done ap27|goal done ap28|goal done ap29|goal done ap30|"
        },
        {
            "domain": "(:types assembly resource) (:predicates (available ?x - (either resource assembly)) (complete ?a - assembly) (requires ?a - assembly ?r - resource) (committed ?r - resource ?a - assembly) (incorporated ?part ?whole - assembly) (part-of ?part ?whole - assembly) (to-be-removed ?part ?whole - assembly) (assemble-order ?part1 ?part2 ?whole - assembly) (transient-part ?part ?whole - assembly) ; After ?part1 is included, ?part2 must be removed ; for the ?whole to be complete: (remove-order ?part1 ?part2 ?whole - assembly)) ",
            "input": "You have one resource and nine assemblies: a-0-0, a-1-0, a-1-1, a-1-2, a-1-3, a-2-0, a-2-1, a-2-2 and a-2-3. The resource is available alongside the assemblies a-1-2, a-2-0, a-2-1, a-2-2 and a-2-3. a-1-0, a-1-1, a-1-2 and a-1-3 is part of a-0-0 while a-2-0 is part of a-1-0, a-2-1 is part of a-1-1, a-2-2 is part of a-1-3 and a-2-3 is part of a-1-3. The assembling order is first a-1-0, second a-1-2, third a-0-0 and first a-1-1, second a-1-2, third a-0-0 and first a-1-1, second a-1-3, third a-0-0 and first a-1-2, second a-1-3, third a-0-0. Please complete a-0-0.",
            "output": "instance r0 resource|instance a-0-0 assembly|instance a-1-0 assembly|instance a-1-1 assembly|instance a-1-2 assembly|instance a-1-3 assembly|instance a-2-0 assembly|instance a-2-1 assembly|instance a-2-2 assembly|instance a-2-3 assembly|predicate part-of a-1-0 a-0-0|predicate part-of a-1-1 a-0-0|predicate part-of a-1-2 a-0-0|predicate part-of a-1-3 a-0-0|predicate part-of a-2-0 a-1-0|predicate part-of a-2-1 a-1-1|predicate part-of a-2-2 a-1-3|predicate part-of a-2-3 a-1-3|predicate assemble-order a-1-0 a-1-2 a-0-0|predicate assemble-order a-1-1 a-1-2 a-0-0|predicate assemble-order a-1-1 a-1-3 a-0-01|predicate assemble-order a-1-2 a-1-3 a-0-0|predicate available a-1-2|predicate available a-2-0|predicate available a-2-1|predicate available a-2-2|predicate available a-2-3|predicate available r0|goal complete a-0-0|"
        },
        {
            "domain": "(:types location locatable - object driver truck obj - locatable ) (:predicates (at ?obj - locatable ?loc - location) (in ?obj1 - obj ?obj - truck) (driving ?d - driver ?v - truck) (link ?x ?y - location) (path ?x ?y - location) (empty ?v - truck) ) ",
            "input": "Commence a logistics operation with two drivers, two trucks, and two packages distributed across locations s0 and s1. Driver1 and Driver2 start at s0, while Truck1 and Truck2, both empty, are at s1. Package1 starts at s0, and Package2 at s1. The locations s0 and s1 are connected directly and also through a path via p0-1. Your task is to orchestrate the drivers and trucks so that Driver1 ends up back at s0, Driver2 at s1, Truck1 and Truck2 at s0, with Package1 moved to s1 and Package2 to s0, utilizing the paths and links available between the locations. s0 is linked to s1 and vice versa. There are paths from s0 to p0-1, s1 to p0-1 and vice versa.",
            "output": "instance driver1 driver|instance driver2 driver|instance truck1 truck|instance truck2 truck|instance package1 obj|instance package2 obj|instance s0 location|instance s1 location|instance p0-1 location|instance p1-0 location|predicate at driver1 s0|predicate at driver2 s0|predicate at truck1 s1|predicate empty truck1|predicate at truck2 s1|predicate empty truck2|predicate at package1 s0|predicate at package2 s1|predicate path s0 p0-1|predicate path p0-1 s0|predicate path s1 p0-1|predicate path p0-1 s1|predicate link s0 s1|predicate link s1 s0|goal at driver1 s0|goal at driver2 s1|goal at truck1 s0|goal at truck2 s0|goal at package1 s1|goal at package2 s0|"
        },
        {
            "domain": "(:types space fuel location movable - object vehicle cargo - movable) (:predicates (at ?v - movable ?l - location) (conn ?l1 ?l2 - location) (has-fuel ?l - location ?f - fuel) (fuel-neighbor ?f1 ?f2 - fuel) (in ?c - cargo ?v - vehicle) (has-space ?v - vehicle ?s - space) (space-neighbor ?s1 ?s2 - space) ) ",
            "input": "Manage the logistics operations involving one vehicle and its cargo across two locations connected directly to each other. Ensure the vehicle is properly fueled and has sufficient space for cargo. Initially, position the vehicle and its cargo at location l1, with fuel available at both locations, and establish a connection between these two locations. Your objective is to successfully transport the cargo from location l1 to location l0 using the vehicle, making sure it utilizes the available fuel and space resources efficiently. Setup the necessary conditions to reflect the connectivity between fuel and space requirements at both locations.",
            "output": "instance f0 fuel|instance f1 fuel|instance s0 space|instance s1 space|instance l0 location|instance l1 location|instance v0 vehicle|instance c0 cargo|predicate fuel-neighbor f0 f1|predicate space-neighbor s0 s1|predicate conn l0 l1|predicate conn l1 l0|predicate has-fuel l0 f0|predicate has-fuel l1 f0|predicate has-space v0 s1|predicate at v0 l1|predicate at c0 l1|goal at c0 l0|"
        },
        {
            "domain": "(:types LOC DIR BOX) (:predicates (at-robot ?l - LOC) (at ?o - BOX ?l - LOC) (adjacent ?l1 - LOC ?l2 - LOC ?d - DIR) (clear ?l - LOC) ) ",
            "input": "Arrange a robot navigation system within a 5x5 grid where each location has specific directional adjacencies. Place the robot at the initial location, and a single box at another specified location within this grid. Ensure that all paths between grid locations are correctly defined in terms of being adjacent either right, left, up, or down. Your main goal is to direct the robot to move the box to a designated location on the grid, making sure the robot's path is clear and no other objects obstruct its movement. Define the initial conditions such as the robot’s starting point, the box's location, and the desired final location for the box.",
            "output": "instance up DIR|instance down DIR|instance left DIR|instance right DIR|instance box0 BOX|instance f0-0f LOC|instance f0-1f LOC|instance f0-2f LOC|instance f0-3f LOC|instance f0-4f LOC|instance f1-0f LOC|instance f1-1f LOC|instance f1-2f LOC|instance f1-3f LOC|instance f1-4f LOC|instance f2-0f LOC|instance f2-1f LOC|instance f2-2f LOC|instance f2-3f LOC|instance f2-4f LOC|instance f3-0f LOC|instance f3-1f LOC|instance f3-2f LOC|instance f3-3f LOC|instance f3-4f LOC|instance f4-0f LOC|instance f4-1f LOC|instance f4-2f LOC|instance f4-3f LOC|instance f4-4f LOC|predicate adjacent f0-0f f0-1f right|predicate adjacent f0-0f f1-0f down|predicate adjacent f0-1f f0-0f left|predicate adjacent f0-1f f0-2f right|predicate adjacent f0-1f f1-1f down|predicate adjacent f0-2f f0-1f left|predicate adjacent f0-2f f0-3f right|predicate adjacent f0-2f f1-2f down|predicate adjacent f0-3f f0-2f left|predicate adjacent f0-3f f0-4f right|predicate adjacent f0-3f f1-3f down|predicate adjacent f0-4f f0-3f left|predicate adjacent f0-4f f1-4f down|predicate adjacent f1-0f f1-1f right|predicate adjacent f1-0f f0-0f up|predicate adjacent f1-0f f2-0f down|predicate adjacent f1-1f f1-0f left|predicate adjacent f1-1f f1-2f right|predicate adjacent f1-1f f0-1f up|predicate adjacent f1-1f f2-1f down|predicate adjacent f1-2f f1-1f left|predicate adjacent f1-2f f1-3f right|predicate adjacent f1-2f f0-2f up|predicate adjacent f1-2f f2-2f down|predicate adjacent f1-3f f1-2f left|predicate adjacent f1-3f f1-4f right|predicate adjacent f1-3f f0-3f up|predicate adjacent f1-3f f2-3f down|predicate adjacent f1-4f f1-3f left|predicate adjacent f1-4f f0-4f up|predicate adjacent f1-4f f2-4f down|predicate adjacent f2-0f f2-1f right|predicate adjacent f2-0f f1-0f up|predicate adjacent f2-0f f3-0f down|predicate adjacent f2-1f f2-0f left|predicate adjacent f2-1f f2-2f right|predicate adjacent f2-1f f1-1f up|predicate adjacent f2-1f f3-1f down|predicate adjacent f2-2f f2-1f left|predicate adjacent f2-2f f2-3f right|predicate adjacent f2-2f f1-2f up|predicate adjacent f2-2f f3-2f down|predicate adjacent f2-3f f2-2f left|predicate adjacent f2-3f f2-4f right|predicate adjacent f2-3f f1-3f up|predicate adjacent f2-3f f3-3f down|predicate adjacent f2-4f f2-3f left|predicate adjacent f2-4f f1-4f up|predicate adjacent f2-4f f3-4f down|predicate adjacent f3-0f f3-1f right|predicate adjacent f3-0f f2-0f up|predicate adjacent f3-0f f4-0f down|predicate adjacent f3-1f f3-0f left|predicate adjacent f3-1f f3-2f right|predicate adjacent f3-1f f2-1f up|predicate adjacent f3-1f f4-1f down|predicate adjacent f3-2f f3-1f left|predicate adjacent f3-2f f3-3f right|predicate adjacent f3-2f f2-2f up|predicate adjacent f3-2f f4-2f down|predicate adjacent f3-3f f3-2f left|predicate adjacent f3-3f f3-4f right|predicate adjacent f3-3f f2-3f up|predicate adjacent f3-3f f4-3f down|predicate adjacent f3-4f f3-3f left|predicate adjacent f3-4f f2-4f up|predicate adjacent f3-4f f4-4f down|predicate adjacent f4-0f f4-1f right|predicate adjacent f4-0f f3-0f up|predicate adjacent f4-1f f4-0f left|predicate adjacent f4-1f f4-2f right|predicate adjacent f4-1f f3-1f up|predicate adjacent f4-2f f4-1f left|predicate adjacent f4-2f f4-3f right|predicate adjacent f4-2f f3-2f up|predicate adjacent f4-3f f4-2f left|predicate adjacent f4-3f f4-4f right|predicate adjacent f4-3f f3-3f up|predicate adjacent f4-4f f4-3f left|predicate adjacent f4-4f f3-4f up|predicate at box0 f1-1f|predicate clear f0-0f|predicate clear f0-1f|predicate clear f0-2f|predicate clear f0-3f|predicate clear f0-4f|predicate clear f1-0f|predicate clear f1-2f|predicate clear f1-3f|predicate clear f1-4f|predicate clear f2-0f|predicate clear f2-1f|predicate clear f2-2f|predicate clear f2-3f|predicate clear f2-4f|predicate at-robot f3-0f|predicate clear f3-0f|predicate clear f3-1f|predicate clear f3-2f|predicate clear f3-3f|predicate clear f3-4f|predicate clear f4-0f|predicate clear f4-2f|predicate clear f4-4f|goal at box0 f4-4f|"
        },
        {
            "domain": "(:types acolour awood woodobj machine surface treatmentstatus aboardsize apartsize - object highspeed-saw glazer grinder immersion-varnisher planer saw spray-varnisher - machine board part - woodobj) (:predicates (unused ?obj - part) (available ?obj - woodobj) (surface-condition ?obj - woodobj ?surface - surface) (treatment ?obj - part ?treatment - treatmentstatus) (colour ?obj - part ?colour - acolour) (wood ?obj - woodobj ?wood - awood) (boardsize ?board - board ?size - aboardsize) (goalsize ?part - part ?size - apartsize) (boardsize-successor ?size1 ?size2 - aboardsize) (in-highspeed-saw ?b - board ?m - highspeed-saw) (empty ?m - highspeed-saw) (has-colour ?machine - machine ?colour - acolour) (contains-part ?b - board ?p - part) (grind-treatment-change ?old ?new - treatmentstatus) (is-smooth ?surface - surface)) ",
            "input": "Set up a woodworking facility with various machines including highspeed saws, glazers, grinders, varnishers, planers, and saws, each equipped with specific colors like blue and mauve. Introduce a selection of wood objects and parts such as boards and parts, specifying their wood type like teak or beech, their surface condition, and required treatments. Define a system where you can track changes in wood treatment from varnished to glazed and identify the smoothness of surfaces. Your objective is to process a part named P0 through various treatments to achieve a specified color and surface smoothness while managing the cost. Include another part P1 to be processed, ensuring all parts are properly sized and meet the end requirements. All machinery should be initialized as available or empty, ready for operation.",
            "output": "instance highspeed-saw0 highspeed-saw|instance glazer0 glazer|instance grinder0 grinder|instance immersion-varnisher0 immersion-varnisher|instance planer0 planer|instance saw0 saw|instance spray-varnisher0 spray-varnisher|instance blue acolour|instance mauve acolour|instance teak awood|instance beech awood|instance p0 part|instance p1 part|instance b0 board|instance s0 aboardsize|instance s1 aboardsize|instance s2 aboardsize|instance s3 aboardsize|predicate grind-treatment-change varnished colourfragments|predicate grind-treatment-change glazed untreated|predicate grind-treatment-change untreated untreated|predicate grind-treatment-change colourfragments untreated|predicate is-smooth smooth|predicate is-smooth verysmooth|predicate total-cost 0|predicate boardsize-successor s0 s1|predicate boardsize-successor s1 s2|predicate boardsize-successor s2 s3|predicate empty highspeed-saw0|predicate has-colour glazer0 mauve|predicate has-colour immersion-varnisher0 natural|predicate has-colour spray-varnisher0 natural|predicate available p0|predicate treatment p0 glazed|predicate surface-condition p0 rough|predicate wood p0 beech|predicate colour p0 blue|predicate goalsize p0 small|predicate spray-varnish-cost p0 5|predicate glaze-cost p0 10|predicate grind-cost p0 15|predicate plane-cost p0 10|predicate unused p1|predicate goalsize p1 medium|predicate spray-varnish-cost p1 10|predicate glaze-cost p1 15|predicate grind-cost p1 30|predicate plane-cost p1 20|predicate boardsize b0 s3|predicate wood b0 beech|predicate surface-condition b0 rough|predicate available b0|goal available p0|goal treatment p0 varnished|goal colour p0 natural|goal available p1|goal wood p1 beech|goal surface-condition p1 smooth|"
        },
        {
            "domain": "(:types cell num group - object) (:predicates (NEXT ?n1 - num ?n2 - num) (CONNECTED ?c - cell ?c2 - cell) ; Defines the graph structure (SOURCE ?x - cell ?g - group) ; The initial position from which the robot must start painting (painted ?r - cell) ; Whether a tile has been painted (available ?x - cell) ; A cell does not belong to any group (part-of ?x - cell ?y - group) ; Whether a cell \"belongs to\" a group. This happens when an adjacent cell belongs to such group (blocked ?x - cell) ; A cell belongs to two different groups so it cannot be painted of any color (remaining-cells ?x - group ?y - num) ; How many tiles remain to be painted for every group (robot-pos ?x - cell) ; Position of the robot (moving) ; The robot is currently not painting (painting ?g - group) ; The robot is currently painting a group (group-painted ?g - group) ; The robot has painted a group ) ",
            "input": "Organize a game on a 3x3 grid where cells need to be painted by a robot starting from a specific cell. Each cell is connected to adjacent cells, forming a network that the robot can navigate. Designate specific cells as sources for distinct groups and define paths of connectivity between cells. Some cells should remain available for the robot to access. Assign numerical values to represent how many cells remain to be painted in each group. Your task is to program the robot to start at a specified cell and paint cells belonging to defined groups, adhering to the layout and connections established, ensuring all necessary cells are painted as required by the game's objectives.",
            "output": "instance pos-0-0 cell|instance pos-0-1 cell|instance pos-0-2 cell|instance pos-1-0 cell|instance pos-1-1 cell|instance pos-1-2 cell|instance pos-2-0 cell|instance pos-2-1 cell|instance pos-2-2 cell|instance n1 num|instance n2 num|instance n3 num|instance n4 num|instance g0 group|instance g1 group|predicate NEXT n0 n1|predicate NEXT n1 n2|predicate NEXT n2 n3|predicate NEXT n3 n4|predicate CONNECTED pos-0-0 pos-1-0|predicate CONNECTED pos-0-0 pos-0-1|predicate CONNECTED pos-0-1 pos-1-1|predicate CONNECTED pos-0-1 pos-0-2|predicate CONNECTED pos-0-1 pos-0-0|predicate CONNECTED pos-0-2 pos-1-2|predicate CONNECTED pos-0-2 pos-0-1|predicate CONNECTED pos-1-0 pos-2-0|predicate CONNECTED pos-1-0 pos-1-1|predicate CONNECTED pos-1-0 pos-0-0|predicate CONNECTED pos-1-1 pos-2-1|predicate CONNECTED pos-1-1 pos-1-2|predicate CONNECTED pos-1-1 pos-0-1|predicate CONNECTED pos-1-1 pos-1-0|predicate CONNECTED pos-1-2 pos-2-2|predicate CONNECTED pos-1-2 pos-0-2|predicate CONNECTED pos-1-2 pos-1-1|predicate CONNECTED pos-2-0 pos-2-1|predicate CONNECTED pos-2-0 pos-1-0|predicate CONNECTED pos-2-1 pos-2-2|predicate CONNECTED pos-2-1 pos-1-1|predicate CONNECTED pos-2-1 pos-2-0|predicate CONNECTED pos-2-2 pos-1-2|predicate CONNECTED pos-2-2 pos-2-1|predicate robot-pos pos-0-0|predicate moving|predicate SOURCE pos-1-0 g0|predicate SOURCE pos-2-2 g1|predicate available pos-0-1|predicate available pos-0-2|predicate part-of pos-2-0 g0|predicate part-of pos-1-1 g0|predicate part-of pos-0-0 g0|predicate part-of pos-1-2 g1|predicate part-of pos-2-1 g1|predicate remaining-cells g0 n4|predicate remaining-cells g1 n1|goal group-painted g0|goal group-painted g1|"
        },
        {
            "domain": "(:types one_square two_straight right_l - pieces position ) (:predicates (clear ?xy - position) (connected ?x - position ?y - position ) (at_square ?element - one_square ?xy - position) (at_two ?element - two_straight ?xy - position ?xy2 - position) (at_right_l ?element - right_l ?xy - position ?xy2 - position ?xy3 - position) ) ",
            "input": "Please arrange a 4x4 grid with various Tetris-like pieces including one-square pieces and right-L-shaped pieces. Connect each grid position to its adjacent positions both horizontally and vertically. Place three one-square pieces at specific grid positions, and two right-L-shaped pieces in a way that they span multiple grid slots. Also, ensure that certain positions remain clear as specified. Your goal is to fit all pieces correctly on the grid, ensuring the specified positions are occupied or left clear as required.",
            "output": "instance f0-0f position|instance f0-1f position|instance f0-2f position|instance f0-3f position|instance f1-0f position|instance f1-1f position|instance f1-2f position|instance f1-3f position|instance f2-0f position|instance f2-1f position|instance f2-2f position|instance f2-3f position|instance f3-0f position|instance f3-1f position|instance f3-2f position|instance f3-3f position|instance square0 one_square|instance square1 one_square|instance square2 one_square|instance nada- two_straight|instance rightl0 right_l|instance rightl1 right_l|predicate connected f0-0f f0-1f|predicate connected f0-1f f0-0f|predicate connected f0-1f f0-2f|predicate connected f0-2f f0-1f|predicate connected f0-2f f0-3f|predicate connected f0-3f f0-2f|predicate connected f1-0f f1-1f|predicate connected f1-1f f1-0f|predicate connected f1-1f f1-2f|predicate connected f1-2f f1-1f|predicate connected f1-2f f1-3f|predicate connected f1-3f f1-2f|predicate connected f2-0f f2-1f|predicate connected f2-1f f2-0f|predicate connected f2-1f f2-2f|predicate connected f2-2f f2-1f|predicate connected f2-2f f2-3f|predicate connected f2-3f f2-2f|predicate connected f3-0f f3-1f|predicate connected f3-1f f3-0f|predicate connected f3-1f f3-2f|predicate connected f3-2f f3-1f|predicate connected f3-2f f3-3f|predicate connected f3-3f f3-2f|predicate connected f0-0f f1-0f|predicate connected f1-0f f0-0f|predicate connected f0-1f f1-1f|predicate connected f1-1f f0-1f|predicate connected f0-2f f1-2f|predicate connected f1-2f f0-2f|predicate connected f0-3f f1-3f|predicate connected f1-3f f0-3f|predicate connected f1-0f f2-0f|predicate connected f2-0f f1-0f|predicate connected f1-1f f2-1f|predicate connected f2-1f f1-1f|predicate connected f1-2f f2-2f|predicate connected f2-2f f1-2f|predicate connected f1-3f f2-3f|predicate connected f2-3f f1-3f|predicate connected f2-0f f3-0f|predicate connected f3-0f f2-0f|predicate connected f2-1f f3-1f|predicate connected f3-1f f2-1f|predicate connected f2-2f f3-2f|predicate connected f3-2f f2-2f|predicate connected f2-3f f3-3f|predicate connected f3-3f f2-3f|predicate clear f0-2f|predicate clear f0-3f|predicate clear f1-3f|predicate clear f3-0f|predicate clear f3-1f|predicate clear f3-2f|predicate clear f3-3f|predicate at_right_l rightl0 f1-0f f2-0f f2-1f|predicate at_right_l rightl1 f1-2f f2-2f f2-3f|predicate at_square square0 f0-0f|predicate at_square square1 f0-1f|predicate at_square square2 f1-1f|goal clear f0-0f|goal clear f0-1f|goal clear f0-2f|goal clear f0-3f|goal clear f1-0f|goal clear f1-1f|goal clear f1-2f|goal clear f1-3f|"
        },
        {
            "domain": "(:types robot tile color - object) (:predicates (robot-at ?r - robot ?x - tile) (up ?x - tile ?y - tile) (down ?x - tile ?y - tile) (right ?x - tile ?y - tile) (left ?x - tile ?y - tile) (clear ?x - tile) (painted ?x - tile ?c - color) (robot-has ?r - robot ?c - color) (available-color ?c - color) (free-color ?r - robot)) ",
            "input": "Deploy two robots equipped with paint on a grid consisting of six tiles, and assign each robot a unique color for the task of painting specific tiles. The robots must navigate and paint in a pattern ensuring directional adjacency is respected—tiles above, below, left, and right are correctly identified. Tiles are initially clear, awaiting paint. Robot 1, located at the center tile on the left side and holding white paint, must paint its current tile white. Robot 2, located at the top middle tile and holding black paint, must paint the directly adjacent tiles in a checkerboard pattern, coordinating to fill in alternating colors without overlap. Ensure that each color is used where specified, and that all movements adhere to the allowed tile connections.",
            "output": "instance tile_0-1 tile|instance tile_0-2 tile|instance tile_1-1 tile|instance tile_1-2 tile|instance tile_2-1 tile|instance tile_2-2 tile|instance robot1 robot|instance robot2 robot|instance white color|instance black color|predicate robot-at robot1 tile_1-1|predicate robot-has robot1 white|predicate robot-at robot2 tile_0-2|predicate robot-has robot2 black|predicate available-color white|predicate available-color black|predicate clear tile_0-1|predicate clear tile_1-2|predicate clear tile_2-1|predicate clear tile_2-2|predicate up tile_1-1 tile_0-1|predicate up tile_1-2 tile_0-2|predicate up tile_2-1 tile_1-1|predicate up tile_2-2 tile_1-2|predicate down tile_0-1 tile_1-1|predicate down tile_0-2 tile_1-2|predicate down tile_1-1 tile_2-1|predicate down tile_1-2 tile_2-2|predicate right tile_0-2 tile_0-1|predicate right tile_1-2 tile_1-1|predicate right tile_2-2 tile_2-1|predicate left tile_0-1 tile_0-2|predicate left tile_1-1 tile_1-2|predicate left tile_2-1 tile_2-2|goal painted tile_1-1 white|goal painted tile_1-2 black|goal painted tile_2-1 black|goal painted tile_2-2 white|"
        },
        {
            "domain": "(:types match fuse) (:predicates (handfree) (unused ?match - match) (mended ?fuse - fuse) (light ?match - match)) ",
            "input": "Organize a task where you have four matches, all initially unused, and eight fuses that need to be mended. Your hands are free to start the task. You are required to mend all eight fuses using the available matches. Each match can only be used when your hands are free, ensuring that each fuse is mended effectively. The goal is to mend every fuse to restore functionality to the system.",
            "output": "instance match0 match|instance match1 match|instance match2 match|instance match3 match|instance fuse0 fuse|instance fuse1 fuse|instance fuse2 fuse|instance fuse3 fuse|instance fuse4 fuse|instance fuse5 fuse|instance fuse6 fuse|instance fuse7 fuse|predicate handfree|predicate unused match0|predicate unused match1|predicate unused match2|predicate unused match3|goal mended fuse0|goal mended fuse1|goal mended fuse2|goal mended fuse3|goal mended fuse4|goal mended fuse5|goal mended fuse6|goal mended fuse7|"
        },
        {
            "domain": "(:types LOC) (:predicates (robot-at ?x - LOC) (bomb-at ?x - LOC ) (laser-at ?x - LOC) (soft-rock-at ?x - LOC) (hard-rock-at ?x - LOC) (gold-at ?x - LOC) (arm-empty) (holds-bomb) (holds-laser) (holds-gold) (clear ?x - LOC) (connected ?x - LOC ?y - LOC) ) ",
            "input": "Direct a robot to navigate a grid, consisting of four specific locations, to collect a gold item. The robot starts with empty hands at the location f1-0f. There are various objects scattered: a bomb and a laser at f0-0f, gold at f0-1f, soft rock at f0-1f, and hard rock at f1-1f. The layout is connected in a simple square grid. Your mission is to guide the robot to collect the gold while managing the obstacles present in each location. The ultimate goal is for the robot to hold the gold, ensuring that it successfully navigates around bombs and rocks to reach it.",
            "output": "instance f0-0f LOC|instance f0-1f LOC|instancef1-0f LOC|instance f1-1f LOC|predicate arm-empty|predicate connected f0-0f f0-1f|predicate connected f1-0f f1-1f|predicate connected f0-0f f1-0f|predicate connected f0-1f f1-1f|predicate connected f0-1f f0-0f|predicate connected f1-1f f1-0f|predicate connected f1-0f f0-0f|predicate connected f1-1f f0-1f|predicate bomb-at f0-0f|predicate laser-at f0-0f|predicate clear f0-0f|predicate gold-at f0-1f|predicate soft-rock-at f0-1f|predicate robot-at f1-0f|predicate clear f1-0f|predicate hard-rock-at f1-1f|goal holds-gold|"
        },
        {
            "domain": "(:types location space fuel locatable - object vehicle cargo - locatable) (:predicates (at ?o - locatable ?l - location) (conn ?l1 ?l2 - location) (has-fuel ?l - location ?f - fuel) (fuel-neighbor ?f1 ?f2 - fuel) (in ?c - cargo ?v - vehicle) (has-space ?v - vehicle ?s - space) (space-neighbor ?s1 ?s2 - space) (not-equal ?l1 ?l2 - location) ) ",
            "input": "Organize a transport operation involving a vehicle and cargo across two locations. The vehicle is initially stationed at location l1 and the cargo at l0. The locations l0 and l1 are connected directly and have different fuel and space capacities. Location l0 is fueled by f1, and l1 by f0. Additionally, they are part of a space network where s0 and s1 are neighbors. Your task is to ensure the cargo is moved from l0 to l1 using the vehicle, which has sufficient space s1. The aim is to end up with the cargo successfully relocated to l0.",
            "output": "instance f0 fuel|instance f1 fuel|instance s0 space|instance s1 space|instance l0 location|instance l1 location|instance v0 vehicle|instance c0 cargo|predicate not-equal l0 l1|predicate not-equal l1 l0|predicate fuel-neighbor f0 f1|predicate space-neighbor s0 s1|predicate conn l0 l1|predicate conn l1 l0|predicate has-fuel l0 f1|predicate has-fuel l1 f0|predicate has-space v0 s1|predicate at v0 l1|predicate at c0 l0|goal at c0 l0|"
        },
        {
            "domain": "(:types hand level beverage dispenser container - object ingredient cocktail - beverage shot shaker - container) (:predicates (ontable ?c - container) (holding ?h - hand ?c - container) (handempty ?h - hand) (empty ?c - container) (contains ?c - container ?b - beverage) (clean ?c - container) (used ?c - container ?b - beverage) (dispenses ?d - dispenser ?i - ingredient) (shaker-empty-level ?s - shaker ?l - level) (shaker-level ?s - shaker ?l - level) (next ?l1 ?l2 - level) (unshaked ?s - shaker) (shaked ?s - shaker) (cocktail-part1 ?c - cocktail ?i - ingredient) (cocktail-part2 ?c - cocktail ?i - ingredient)) ",
            "input": "You have two empty hands. On the table in front of you, you have one clean and empty shaker and two clean and empty shots. The two dispenser dispenses two different ingredients. Please make me a cocktail with one of the shots.",
            "output": "instance shaker1 shaker|instance left hand|instance right hand|instance shot1|instance shot2 shot|instance ingredient1 ingredient|instance ingredient2 ingredient|instance cocktail1 cocktail|instance cocktail2 cocktail|instance dispenser1 dispenser|instance dispenser2 dispenser|instance l0 level|instance l1 level|instance l2 level|predicate ontable shaker1|predicate ontable shot1|predicate ontable shot2|predicate dispenses dispenser1 ingredient1|predicate dispenses dispenser2 ingredient2|predicate clean shaker1|predicate clean shot1|predicate clean shot2|predicate empty shaker1|predicate empty shot1|predicate empty shot2|predicate handempty left|predicate handempty right|predicate shaker-empty-level shaker1 l0|predicate shaker-level shaker1 l0|predicate next l0 l1|predicate l1 l2|predicate cocktail-part1 cocktail1 ingredient1|predicate cocktail-part2 cocktail1 ingredient2|goal contains shot1 cocktail1|"
        },
        {
            "domain": "(:types room object robot gripper) (:predicates (at-robby ?r - robot ?x - room) (at ?o - object ?x - room) (free ?r - robot ?g - gripper) (carry ?r - robot ?o - object ?g - gripper)) ",
            "input": "Organize a robotic movement task where Robot1, equipped with two grippers (rgripper1 and lgripper1), both initially free, needs to transport objects between rooms. Robot1 starts in room2. There are two objects: ball1 is located in room1, and ball2 is in the same room as Robot1 (room2). The task is to move ball1 to room2 and ball2 to room3. Make sure the robot successfully relocates each object to its designated room using its available grippers.",
            "output": "instance robot1 robot|instance rgripper1 gripper|instance lgripper1 gripper|instance room1 room|instance room2 room|instance room3 room|instance ball1 object|instance ball2 object|predicate at-robby robot1 room2|predicate free robot1 rgripper1|predicate free robot1 lgripper1|predicate at ball1 room1|predicate at ball2 room2|goal at ball1 room2|goal at ball2 room3|"
        },
        {
            "domain": "(:types location diver tank quantity) (:predicates (at-tank ?t - tank ?l - location) (in-storage ?t - tank) (full ?t - tank) (next-tank ?t1 - tank ?t2 - tank) (at-diver ?d - diver ?l - location) (available ?d - diver) (at-surface ?d - diver) (decompressing ?d - diver) (precludes ?d1 - diver ?d2 - diver) (cave-entrance ?l - location) (connected ?l1 - location ?l2 - location) (next-quantity ?q1 - quantity ?q2 - quantity) (holding ?d - diver ?t - tank) (capacity ?d - diver ?q - quantity) (have-photo ?l - location) (in-water ) ) ",
            "input": "Organize a cave diving expedition to photograph objectives in locations l3 and l4. Start by hiring divers who can work together without issues, considering their hiring costs and air tank capacities. Prepare and strategically place air tanks through the cave system for the divers to use. Ensure all divers decompress after their single trip into the cave. Achieve the goals with minimal total cost. There are five locations, six divers, 24 tanks including a dummy tank and five qunatity levels. Initially, all tanks are available and at max capacity. Next tanks are ordered, cave entrance is at the first location and all caves are connected in series. The tank quantities goes from increasing/decreasing. You can decide how the divers preclude and also all the costs. The goal is to have a photo at location 2 and 3 and all divers decompressed.",
            "output": "instance l0 location|instance l1 location|instance l2 location|instance l3 location|instance l4 location|instance d0 diver|instance d1 diver|instance d2 diver|instance d3 diver|instance d4 diver|instance d5 diver|instance t0 tank|instance t1 tank|instance t2 tank|instance t3 tank|instance t4 tank|instance t5 tank|instance t6 tank|instance t7 tank|instance t8 tank|instance t9 tank|instance t10 tank|instance t11 tank|instance t12 tank|instance t13 tank|instance t14 tank|instance t15 tank|instance t16 tank|instance t17 tank|instance t18 tank|instance t19 tank|instance t20 tank|instance t21 tank|instance t22 tank|instance dummy tank|instance zero quantity|instance one quantity|instance two quantity|instance three quantity|instance four quantity|predicate available d0|predicate available d1|predicate available d2|predicate available d3|predicate available d4|predicate available d5|predicate capacity d0 four|predicate capacity d1 four|predicate capacity d2 four|predicate capacity d3 four|predicate capacity d4 four|predicate capacity d5 four|predicate in-storage t0|predicate next-tank t0 t1|predicate next-tank t1 t2|predicate next-tank t2 t3|predicate next-tank t3 t4|predicate next-tank t4 t5|predicate next-tank t5 t6|predicate next-tank t6 t7|predicate next-tank t7 t8|predicate next-tank t8 t9|predicate next-tank t9 t10|predicate next-tank t10 t11|predicate next-tank t11 t12|predicate next-tank t12 t13|predicate next-tank t13 t14|predicate next-tank t14 t15|predicate next-tank t15 t16|predicate next-tank t16 t17|predicate next-tank t17 t18|predicate next-tank t18 t19|predicate next-tank t19 t20|predicate next-tank t20 t21|predicate next-tank t21 t22|predicate next-tank t22 dummy|predicate cave-entrance l0|predicate connected l0 l1|predicate connected l1 l0|predicate connected l1 l2|predicate connected l2 l1|predicate connected l2 l3|predicate connected l3 l2|predicate connected l1 l4|predicate connected l4 l1|predicate next-quantity zero one|predicate next-quantity one two|predicate next-quantity two three|predicate next-quantity three four|predicate precludes d2 d3|predicate precludes d2 d5|predicate precludes d0 d1|predicate precludes d3 d5|predicate precludes d3 d4|predicate precludes d5 d1|cost hiring d0 43|cost hiring d1 71|cost hiring d2 10|cost hiring d3 10|cost hiring d4 74|cost hiring d5 40|cost other 1|cost total-cost 0|goal have-photo l3|goal have-photo l4|goal decompressing d0|goal decompressing d1|goal decompressing d2|goal decompressing d3|goal decompressing d4|goal decompressing d5|"
        }
    ]
}