{
    "shots": [
        { // schedule
            "domain": "(:types temperature-type ashape surface machine part colour width anorient) (:predicates (temperature ?obj - part ?temp - temperature-type) (busy ?machine - machine) (scheduled ?obj - part) (objscheduled) (surface-condition ?obj - part ?surface-cond - surface) (shape ?obj - part ?shape - ashape) (painted ?obj - part ?colour - colour) (has-hole ?obj - part ?width - width ?orientation - anorient) (has-bit ?machine - machine ?width - width) (can-orient ?machine - machine ?orientation - anorient) (has-paint ?machine - machine ?colour - colour)) ",
            "input": "",
            "output": ""
        },
        { // rover
            "domain": "(:types rover waypoint store camera mode lander objective) (:predicates (at ?x - rover ?y - waypoint) (at_lander ?x - lander ?y - waypoint) (can_traverse ?r - rover ?x - waypoint ?y - waypoint) (equipped_for_soil_analysis ?r - rover) (equipped_for_rock_analysis ?r - rover) (equipped_for_imaging ?r - rover) (empty ?s - store) (have_rock_analysis ?r - rover ?w - waypoint) (have_soil_analysis ?r - rover ?w - waypoint) (full ?s - store) (calibrated ?c - camera ?r - rover) (supports ?c - camera ?m - mode) (available ?r - rover) (visible ?w - waypoint ?p - waypoint) (have_image ?r - rover ?o - objective ?m - mode) (communicated_soil_data ?w - waypoint) (communicated_rock_data ?w - waypoint) (communicated_image_data ?o - objective ?m - mode) (at_soil_sample ?w - waypoint) (at_rock_sample ?w - waypoint) (visible_from ?o - objective ?w - waypoint) (store_of ?s - store ?r - rover) (calibration_target ?i - camera ?o - objective) (on_board ?i - camera ?r - rover) (channel_free ?l - lander)) ",
            "input": "",
            "output": ""
        },
        { // child-snack
            "domain": "(:types child bread-portion content-portion sandwich tray place) (:predicates (at_kitchen_bread ?b - bread-portion) (at_kitchen_content ?c - content-portion) (at_kitchen_sandwich ?s - sandwich) (no_gluten_bread ?b - bread-portion) (no_gluten_content ?c - content-portion) (ontray ?s - sandwich ?t - tray) (no_gluten_sandwich ?s - sandwich) (allergic_gluten ?c - child) (not_allergic_gluten ?c - child) (served ?c - child) (waiting ?c - child ?p - place) (at ?t - tray ?p - place) (notexist ?s - sandwich) ) ",
            "input": "In the kitchen, there are three portions each of bread and content to make sandwiches, with bread1 being gluten-free and content3 also gluten-free. There are two trays in the kitchen ready to use. Child1, who is allergic to gluten, is waiting at table2, while child2 and child3, who are not allergic to gluten, are waiting at table1 and table2, respectively. You need to prepare sandwiches, considering the dietary restrictions, and serve them to the children at their respective tables. There are four sandwiches to be made and named from sandw1 to sandw4, which currently do not exist.",
            "output": "instance child1 child|instance child2 child|instance child3 child|instance bread1 bread-portion|instance bread2 bread-portion|instance bread3 bread-portion|instance content1 content-portion|instance content2 content-portion|instance content3 content-portion|instance tray1 tray|instance tray2 tray|instance table1 place|instance table2 place|instance table3 place|instance sandw1 sandwich|instance sandw2 sandwich|instance sandw3 sandwich|instance sandw4 sandwich|instance kitchen place|predicate at tray1 kitchen|predicate at tray2 kitchen|predicate at_kitchen_bread bread1|predicate at_kitchen_bread bread2|predicate at_kitchen_bread bread3|predicate at_kitchen_content content1|predicate at_kitchen_content content2|predicate at_kitchen_content content3|predicate no_gluten_bread bread1|predicate no_gluten_content content3|predicate allergic_gluten child1|predicate not_allergic_gluten child3|predicate not_allergic_gluten child2|predicate waiting child1 table2|predicate waiting child2 table1|predicate waiting child3 table2|predicate notexist sandw1|predicate notexist sandw2|predicate notexist sandw3|predicate notexist sandw4|goal served child1|goal served child2|goal served child3|"
        },
        { // spanner
            "domain": "(:types location locatable - object man nut spanner - locatable ) (:predicates (at ?m - locatable ?l - location) (carrying ?m - man ?s - spanner) (useable ?s - spanner) (link ?l1 - location ?l2 - location) (tightened ?n - nut) (loose ?n - nut)) ",
            "input": "",
            "output": ""
        },
        { // depots
            "domain": "(:types place locatable - object depot distributor - place truck hoist surface - locatable pallet crate - surface) (:predicates (at ?x - locatable ?y - place) (on ?x - crate ?y - surface) (in ?x - crate ?y - truck) (lifting ?x - hoist ?y - crate) (available ?x - hoist) (clear ?x - surface)) ",
            "input": "",
            "output": ""
        },
        { // miconic
            "domain": "(:types passenger - object going_up going_down vip going_nonstop attendant never_alone conflict_A conflict_B - passenger floor - object ) (:predicates (origin ?person - passenger ?floor - floor) ;; entry of ?person is ?floor ;; inertia (destin ?person - passenger ?floor - floor) ;; exit of ?person is ?floor ;; inertia (no-access ?person - passenger ?floor - floor) ;; access limitation of ?person on ?floor (above ?floor1 - floor ?floor2 - floor) ;; ?floor2 is located above of ?floor1 (boarded ?person - passenger) ;; true if ?person has boarded the lift (served ?person - passenger) ;; true if ?person has alighted as her destination (lift-at ?floor - floor) ;; current position of the lift is at ?floor ) ",
            "input": "",
            "output": ""
        },
        { // citycar
            "domain": "(:types car junction garage road ) (:predicates (same_line ?xy - junction ?xy2 - junction) ;; junctions in line (row) (diagonal ?x - junction ?y - junction ) ;; junctions in diagonal (on the map) (at_car_jun ?c - car ?x - junction) ;; a car is at the junction (at_car_road ?c - car ?x - road) ;; a car is in a road (starting ?c - car ?x - garage) ;; a car is in its initial position (arrived ?c - car ?x - junction) ;; a car arrived at destination (road_connect ?r1 - road ?xy - junction ?xy2 - junction) ;; there is a road that connects 2 junctions (clear ?xy - junction ) ;; the junction is clear (in_place ?x - road);; the road has been put in place (at_garage ?g - garage ?xy - junction ) ;; position of the starting garage ) ",
            "input": "Begin with a grid layout of junctions from junction0-0 to junction2-2, forming a 3x3 matrix. Two cars, car0 and car1, initially start at garage0, located at junction0-1. The city allows for the construction and demolition of roads to facilitate car movement. Your objective is to guide both cars to their destination at junction2-1. You can build straight or diagonal roads between junctions, but each road's construction or demolition incurs specific costs. Ensure that the cars reach their destination with minimal total costs, leveraging the ability to build and remove roads as needed.",
            "output": "instance junction0-0 junction|instance junction0-1 junction|instance junction0-2 junction|instance junction1-0 junction|instance junction1-1 junction|instance junction1-2 junction|instance junction2-0 junction|instance junction2-1 junction|instance junction2-2 junction|instance car0 car|instance car1 car|instance garage0 garage|instance road0 road|instance road1 road|instance road2 road|instance road3 road|instance road4 road|predicate clear junction0-0|predicate clear junction0-1|predicate clear junction0-2|predicate clear junction1-0|predicate clear junction1-1|predicate clear junction1-2|predicate clear junction2-0|predicate clear junction2-1|predicate clear junction2-2|predicate same_line junction0-0 junction0-1|predicate same_line junction0-1 junction0-0|predicate same_line junction0-1 junction0-2|predicate same_line junction0-2 junction0-1|predicate same_line junction1-0 junction1-1|predicate same_line junction1-1 junction1-0|predicate same_line junction1-1 junction1-2|predicate same_line junction1-2 junction1-1|predicate same_line junction2-0 junction2-1|predicate same_line junction2-1 junction2-0|predicate same_line junction2-1 junction2-2|predicate same_line junction2-2 junction2-1|predicate same_line junction0-0 junction1-0|predicate same_line junction1-0 junction0-0|predicate same_line junction1-0 junction2-0|predicate same_line junction2-0 junction1-0|predicate same_line junction0-1 junction1-1|predicate same_line junction1-1 junction0-1|predicate same_line junction1-1 junction2-1|predicate same_line junction2-1 junction1-1|predicate same_line junction0-2 junction1-2|predicate same_line junction1-2 junction0-2|predicate same_line junction1-2 junction2-2|predicate same_line junction2-2 junction1-2|predicate diagonal junction0-0 junction1-1|predicate diagonal junction1-1 junction0-0|predicate diagonal junction0-1 junction1-0|predicate diagonal junction1-0 junction0-1|predicate diagonal junction0-1 junction1-2|predicate diagonal junction1-2 junction0-1|predicate diagonal junction0-2 junction1-1|predicate diagonal junction1-1 junction0-2|predicate diagonal junction1-0 junction2-1|predicate diagonal junction2-1 junction1-0|predicate diagonal junction1-1 junction2-0|predicate diagonal junction2-0 junction1-1|predicate diagonal junction1-1 junction2-2|predicate diagonal junction2-2 junction1-1|predicate diagonal junction1-2 junction2-1|predicate diagonal junction2-1 junction1-2|predicate at_garage garage0 junction0-1|predicate starting car0 garage0|predicate starting car1 garage0|cost total-cost 0|goal arrived car0 junction2-1|goal arrived car1 junction2-1|"
        },
        { // satellite
            "domain": "(:types satellite direction instrument mode) (:predicates (on_board ?i - instrument ?s - satellite) (supports ?i - instrument ?m - mode) (pointing ?s - satellite ?d - direction) (power_avail ?s - satellite) (power_on ?i - instrument) (calibrated ?i - instrument) (have_image ?d - direction ?m - mode) (calibration_target ?i - instrument ?d - direction)) ",
            "input": "",
            "output": ""
        },
        { // depots2
            "domain": "(:types hoist surface place area - object container depot - place storearea transitarea - area area crate - surface) (:predicates (clear ?s - storearea) (in ?x - (either storearea crate) ?p - place) (available ?h - hoist) (lifting ?h - hoist ?c - crate) (at ?h - hoist ?a - area) (on ?c - crate ?s - storearea) (connected ?a1 ?a2 - area) (compatible ?c1 ?c2 - crate)) ",
            "input": "",
            "output": ""
        },
        { // parking
            "domain": "(:types car curb) (:predicates (at-curb ?car - car) (at-curb-num ?car - car ?curb - curb) (behind-car ?car ?front-car - car) (car-clear ?car - car) (curb-clear ?curb - curb) ) ",
            "input": "",
            "output": ""
        },
        { // agricola
            "domain": "(:types actiontag goods stage round worker improvement roundclass phaseclass roundparts resource room num - object buildtag animaltag vegtag gentag - actiontag animal vegetable - goods ) (:predicates (NEXT_STAGE ?s1 ?s2 - stage) (current_stage ?s - stage) (harvest_phase ?s - stage ?hclass - phaseclass) (NEXT_ROUND ?r1 ?r2 - round) (hold_round ?r - round ?p - roundparts) (current_round ?r - round) (category_round ?r - round ?t - roundclass) ;; Family members will be used in descending order ;; the max is the number of member at present (NEXT_WORKER ?w1 ?w2 - worker) (current_worker ?w - worker) (max_worker ?w - worker) (newborn) (plowed_fields) (stored_veg ?v - vegetable) (sown_veg ?v - vegetable) (can_harvest ?v - vegetable) (fences_for ?a - animal) (owned_animals ?a - animal) (can_breed ?a - animal) (NEXT_NUM ?i1 ?i2 - num) (NEXT2_NUM ?i1 ?i2 - num) (NUM_SUBSTRACT ?it - num ?iminus - num ?isol - num) (FOOD_REQUIRED ?w - worker ?i - num) (open_action ?a - actiontag) (available_action ?a - actiontag) (DRAWCARD_ROUND ?a - actiontag ?r - round) (num_food ?i - num) (stored_resource ?r - resource) (SUPPLY_RESOURCE ?s - buildtag ?r - resource) (space_rooms ?r - room) (built_rooms ?r - room ?w - worker) (ok) (home_improvement ?imp - improvement) ) ",
            "input": "",
            "output": ""
        },
        { // briefcase
            "domain": "(:types portable location) (:predicates (at ?y - portable ?x - location) (in ?x - portable) (is-at ?x - location)) ",
            "input": "Transport all the four objects to their respective location: first object to location 3, second object to location 0, third object to location 1 and fourth object at location 2. Also, go to location 1 afterwards. The four objects are now at location 3, location 1, location 2 and location 0 respectively. We are in location 4.",
            "output": "instance l0 location|instance l1 location|instance l2 location|instance l3 location|instance l4 location|instance o0 portable|instance o1 portable|instance o2 portable|instance o3 portable|predicate at o0 l3|predicate at o1 l1|predicate at o2 l2|predicate at o3 l0|predicate is-at l4|goal at o0 l3|goal at o1 l0|goal at o2 l1|goal at o3 l2|goal is-at l1|"
        },
        { // zeno-travel
            "domain": "(:types aircraft person city flevel - object) (:predicates (at ?x - (either person aircraft) ?c - city) (in ?p - person ?a - aircraft) (fuel-level ?a - aircraft ?l - flevel) (next ?l1 ?l2 - flevel)) ",
            "input": "",
            "output": ""
        },
        { // fridge-domain
            "domain": "(:types screw backplane compressor fridge) (:predicates (screwed ?s - screw) (attached ?c - compressor ?f - fridge) (fits ?s - screw ?c -compressor) (fridge-on ?f - fridge)) ",
            "input": "",
            "output": "instance s0-0 screw|instance s0-1 screw|instance s0-2 screw|instance s1-0 screw|instance s1-1 screw|instance s1-2 screw|instance c0-0 compressor|instance c0-1 compressor|instance c1-0 compressor|instance c1-1 compressor|instance f0 fridge|instance f1 fridge|predicate fridge-on f0|predicate attached c0-0 f0|predicate fridge-on f1|predicate attached c1-0 f1|predicate fits s0-0 c0-0|predicate fits s0-0 c0-1|predicate screwed s0-0|predicate fits s0-1 c0-0|predicate fits s0-1 c0-1|predicate screwed s0-1|predicate fits s0-2 c0-0|predicate fits s0-2 c0-1|predicate screwed s0-2|predicate fits s1-0 c1-0|predicate fits s1-0 c1-1|predicate screwed s1-0|predicate fits s1-1 c1-0|predicate fits s1-1 c1-1|predicate screwed s1-1|predicate fits s1-2 c1-0|predicate fits s1-2 c1-1|predicate screwed s1-2|goal attached c0-1 f0|goal fridge-on f0|goal attached c1-1 f1|goal fridge-on f1|"
        },
        { // grid-visit-all
            "domain": "(:types place - object) (:predicates (connected ?x ?y - place) (at-robot ?x - place) (visited ?x - place) ) ",
            "input": "",
            "output": ""
        },
        { // transport-strips
            "domain": "(:types location fuellevel locatable - object package truck - locatable ) (:predicates (connected ?l1 ?l2 - location) (at ?o - locatable ?l - location) (in ?p - package ?t - truck) (fuel ?t - truck ?level - fuellevel) (fuelcost ?level - fuellevel ?l1 ?l2 - location) (sum ?a ?b ?c - fuellevel) ) ",
            "input": "",
            "output": ""
        },
        { // hiking
            "domain": "(:types car tent person couple place ) (:predicates (at_tent ?x1 - tent ?x2 - place) (at_person ?x1 - person ?x2 - place) (at_car ?x1 - car ?x2 - place) (partners ?x1 - couple ?x2 - person ?x3 - person) (up ?x1 - tent) (down ?x1 - tent) (walked ?x1 - couple ?x2 - place) (next ?x1 - place ?x2 - place) ) ",
            "input": "Consider a scenario with three cars (car0, car1, car2), two tents (tent0, tent1), two couples (couple0, couple1), and four places (place0 to place3). The people are guy0, girl0 for couple0, and guy1, girl1 for couple1. Initially, couple0 and couple1 are partners as guy0 is with girl0 and guy1 is with girl1, respectively. Both couples start at place0, where tent0 is set up and up, while tent1 is also at place0 but is down. All three cars are at place0. The places are connected sequentially from place0 to place3. The goal is for both couples to have walked to place3.",
            "output": "instance car0 car|instance car1 car|instance car2 car|instance tent0 tent|instance tent1 tent|instance couple0 couple|instance couple1 couple|instance place0 place|instance place1 place|instance place2 place|instance place3 place|instance guy0 person|instance girl0 person|instance guy1 person|instance girl1 person|predicate partners couple0 guy0 girl0|predicate at_person guy0 place0|predicate at_person girl0 place0|predicate walked couple0 place0|predicate at_tent tent0 place0|predicate up tent0|predicate partners couple1 guy1 girl1|predicate at_person guy1 place0|predicate at_person girl1 place0|predicate walked couple1 place0|predicate at_tent tent1 place0|predicate down tent1|predicate at_car car0 place0|predicate at_car car1 place0|predicate at_car car2 place0|predicate next place0 place1|predicate next place1 place2|predicate next place2 place3|goal walked couple0 place3|goal walked couple1 place3|"
        },
        { // tpp
            "domain": "(:types place locatable level - object depot market - place truck goods - locatable) (:predicates (loaded ?g - goods ?t - truck ?l - level) (ready-to-load ?g - goods ?m - market ?l - level) (stored ?g - goods ?l - level) (on-sale ?g - goods ?m - market ?l - level) (next ?l1 ?l2 - level) (at ?t - truck ?p - place) (connected ?p1 ?p2 - place)) ",
            "input": "Initiate a logistics operation involving one depot and two distributors. You have at your disposal two trucks, three hoists,five pallets and two crates. Pallet one and four are at the depot, pallet two and five is a the first distributor while pallet three is at the second distributor. Pallets three, four and five and crates are cleared at the beginning. The two trucks start at the first distributor. All hoists are available and the three of them are distributed around the depot and the two distributors. First crate is at the depot placed on the first pallet. The second crate is at the first distributor and placed on the second pallet. Your task is to ensure that the first crate ends up on pallet four at the depot, and that the second crate end up on the fifth pallet, also initially at Distributor0. Utilize the trucks and hoists available at each location to move the crates efficiently, respecting the constraint that crates must be lifted from their current pallets before being moved or loaded into trucks.",
            "output": "instance depot0 depot|instance distributor0 distributor|instance distributor1 distributor|instance truck0 truck|instance truck1 truck|instance pallet0 pallet|instance pallet1 pallet|instance pallet2 pallet|instance pallet3 pallet|instance pallet4 pallet|instance crate0 crate|instance crate1 crate|instance hoist0 hoist|instance hoist1 hoist|instance hoist2 hoist|predicate at pallet0 depot0|predicate clear crate0|predicate at pallet1 distributor0|predicate clear crate1|predicate at pallet2 distributor1|predicate clear pallet2|predicate at pallet3 depot0|predicate clear pallet3|predicate at pallet4 distributor0|predicate clear pallet4|predicate at truck0 distributor0|predicate at truck1 distributor0|predicate at hoist0 depot0|predicate available hoist0|predicate at hoist1 distributor0|predicate available hoist1|predicate at hoist2 distributor1|predicate available hoist2|predicate at crate0 depot0|predicate on crate0 pallet0|predicate at crate1 distributor0|predicate on crate1 pallet1|goal on crate0 pallet3|goal on crate1 pallet4|"
        },
        { // tyreworld
            "domain": "(:types obj - object tool wheel nut - obj container hub - object) (:predicates (open ?x) (closed ?x) (have ?x) (in ?x ?y) (loose ?x ?y) (tight ?x ?y) (unlocked ?x) (on-ground ?x) (not-on-ground ?x) (inflated ?x) (not-inflated ?x) (fastened ?x) (unfastened ?x) (free ?x) (on ?x ?y) (intact ?x)) ",
            "input": "",
            "output": ""
        },
        { // maintenance-scheduling-domain
            "domain": "(:types plane day airport) (:predicates (done ?p - plane) (today ?d - day) (at ?p - plane ?d - day ?c - airport) (next ?d - day ?d2 - day) ) ",
            "input": "",
            "output": ""
        },
        { // assembly
            "domain": "(:types assembly resource) (:predicates (available ?x - (either resource assembly)) (complete ?a - assembly) (requires ?a - assembly ?r - resource) (committed ?r - resource ?a - assembly) (incorporated ?part ?whole - assembly) (part-of ?part ?whole - assembly) (to-be-removed ?part ?whole - assembly) (assemble-order ?part1 ?part2 ?whole - assembly) (transient-part ?part ?whole - assembly) ; After ?part1 is included, ?part2 must be removed ; for the ?whole to be complete: (remove-order ?part1 ?part2 ?whole - assembly)) ",
            "input": "You have one resource and nine assemblies: a-0-0, a-1-0, a-1-1, a-1-2, a-1-3, a-2-0, a-2-1, a-2-2 and a-2-3. The resource is available alongside the assemblies a-1-2, a-2-0, a-2-1, a-2-2 and a-2-3. a-1-0, a-1-1, a-1-2 and a-1-3 is part of a-0-0 while a-2-0 is part of a-1-0, a-2-1 is part of a-1-1, a-2-2 is part of a-1-3 and a-2-3 is part of a-1-3. The assembling order is first a-1-0, second a-1-2, third a-0-0 and first a-1-1, second a-1-2, third a-0-0 and first a-1-1, second a-1-3, third a-0-0 and first a-1-2, second a-1-3, third a-0-0. Please complete a-0-0.",
            "output": "instance r0 resource|instance a-0-0 assembly|instance a-1-0 assembly|instance a-1-1 assembly|instance a-1-2 assembly|instance a-1-3 assembly|instance a-2-0 assembly|instance a-2-1 assembly|instance a-2-2 assembly|instance a-2-3 assembly|predicate part-of a-1-0 a-0-0|predicate part-of a-1-1 a-0-0|predicate part-of a-1-2 a-0-0|predicate part-of a-1-3 a-0-0|predicate part-of a-2-0 a-1-0|predicate part-of a-2-1 a-1-1|predicate part-of a-2-2 a-1-3|predicate part-of a-2-3 a-1-3|predicate assemble-order a-1-0 a-1-2 a-0-0|predicate assemble-order a-1-1 a-1-2 a-0-0|predicate assemble-order a-1-1 a-1-3 a-0-01|predicate assemble-order a-1-2 a-1-3 a-0-0|predicate available a-1-2|predicate available a-2-0|predicate available a-2-1|predicate available a-2-2|predicate available a-2-3|predicate available r0|goal complete a-0-0|"
        },
        { // driverlog
            "domain": "(:types location locatable - object driver truck obj - locatable ) (:predicates (at ?obj - locatable ?loc - location) (in ?obj1 - obj ?obj - truck) (driving ?d - driver ?v - truck) (link ?x ?y - location) (path ?x ?y - location) (empty ?v - truck) ) ",
            "input": "Commence a logistics operation with two drivers, two trucks, and two packages distributed across locations s0 and s1. Driver1 and Driver2 start at s0, while Truck1 and Truck2, both empty, are at s1. Package1 starts at s0, and Package2 at s1. The locations s0 and s1 are connected directly and also through a path via p0-1. Your task is to orchestrate the drivers and trucks so that Driver1 ends up back at s0, Driver2 at s1, Truck1 and Truck2 at s0, with Package1 moved to s1 and Package2 to s0, utilizing the paths and links available between the locations. s0 is linked to s1 and vice versa. There are paths from s0 to p0-1, s1 to p0-1 and vice versa.  ",
            "output": "instance driver1 driver|instance driver2 driver|instance truck1 truck|instance truck2 truck|instance package1 obj|instance package2 obj|instance s0 location|instance s1 location|instance p0-1 location|instance p1-0 location|predicate at driver1 s0|predicate at driver2 s0|predicate at truck1 s1|predicate empty truck1|predicate at truck2 s1|predicate empty truck2|predicate at package1 s0|predicate at package2 s1|predicate path s0 p0-1|predicate path p0-1 s0|predicate path s1 p0-1|predicate path p0-1 s1|predicate link s0 s1|predicate link s1 s0|goal at driver1 s0|goal at driver2 s1|goal at truck1 s0|goal at truck2 s0|goal at package1 s1|goal at package2 s0|"
        },
        { // spider
            "domain": "(:types cardposition - object card_or_tableau - cardposition card - card_or_tableau tableau - card_or_tableau deal - cardposition ) (:predicates (on ?c1 - card ?c2 - cardposition) (clear ?c - cardposition) (in-play ?c - card) (current-deal ?d - deal) ; ; static predicates (CAN-CONTINUE-GROUP ?c1 - card ?c2 - cardposition) (CAN-BE-PLACED-ON ?c1 - card ?c2 - card) (IS-ACE ?c - card) (IS-KING ?c - card) (NEXT-DEAL ?d ?nd - deal) (TO-DEAL ?c - card ?p - tableau ?d - deal ?next - cardposition) ; ; control flags for dealing (currently-dealing) ; ; control flags for collecting cards (currently-collecting-deck) (collect-card ?c - cardposition) ; ; derived predicates (part-of-tableau ?c - cardposition ?t - tableau) (movable ?c - card) ; ; control flags for derived predicates (currently-updating-unmovable) (make-unmovable ?c - card) (currently-updating-movable) (make-movable ?c - cardposition) (currently-updating-part-of-tableau) (make-part-of-tableau ?c - card ?t - tableau) ) ",
            "input": "",
            "output": ""
        },
        { // mystery-strips
            "domain": "(:types space fuel location movable - object vehicle cargo - movable) (:predicates (at ?v - movable ?l - location) (conn ?l1 ?l2 - location) (has-fuel ?l - location ?f - fuel) (fuel-neighbor ?f1 ?f2 - fuel) (in ?c - cargo ?v - vehicle) (has-space ?v - vehicle ?s - space) (space-neighbor ?s1 ?s2 - space) ) ",
            "input": "",
            "output": ""
        },
        { // typed-sokoban
            "domain": "(:types LOC DIR BOX) (:predicates (at-robot ?l - LOC) (at ?o - BOX ?l - LOC) (adjacent ?l1 - LOC ?l2 - LOC ?d - DIR) (clear ?l - LOC) ) ",
            "input": "",
            "output": ""
        },
        { // transport
            "domain": "(:types location target locatable - object vehicle package - locatable capacity-number - object ) (:predicates (road ?l1 ?l2 - location) (at ?x - locatable ?v - location) (in ?x - package ?v - vehicle) (capacity ?v - vehicle ?s1 - capacity-number) (capacity-predecessor ?s1 ?s2 - capacity-number) ) ",
            "input": "",
            "output": ""
        },
        {  // freecell
            "domain": "(:types card colnum cellnum num suit) (:predicates (on ?c1 - card ?c2 - card) (incell ?c - card) (clear ?c - card) (cellspace ?n - cellnum) (colspace ?n - colnum) (home ?c - card) (bottomcol ?c - card) (canstack ?c1 - card ?c2 - card) (hassuit ?c - card ?s - suit) (value ?c - card ?v - num) (successor ?n1 - num ?n0 - num) (colsuccessor ?n1 - colnum ?n0 - colnum) (cellsuccessor ?n1 - cellnum ?n0 - cellnum) ) ",
            "input": "",
            "output": ""
        },
        { // elevators-sequencedstrips
            "domain": "(:types elevator - object slow-elevator fast-elevator - elevator passenger - object count - object ) (:predicates (passenger-at ?person - passenger ?floor - count) (boarded ?person - passenger ?lift - elevator) (lift-at ?lift - elevator ?floor - count) (reachable-floor ?lift - elevator ?floor - count) (above ?floor1 - count ?floor2 - count) (passengers ?lift - elevator ?n - count) (can-hold ?lift - elevator ?n - count) (next ?n1 - count ?n2 - count) ) ",
            "input": "",
            "output": ""
        },
        { // woodworking
            "domain": "(:types acolour awood woodobj machine surface treatmentstatus aboardsize apartsize - object highspeed-saw glazer grinder immersion-varnisher planer saw spray-varnisher - machine board part - woodobj) (:predicates (unused ?obj - part) (available ?obj - woodobj) (surface-condition ?obj - woodobj ?surface - surface) (treatment ?obj - part ?treatment - treatmentstatus) (colour ?obj - part ?colour - acolour) (wood ?obj - woodobj ?wood - awood) (boardsize ?board - board ?size - aboardsize) (goalsize ?part - part ?size - apartsize) (boardsize-successor ?size1 ?size2 - aboardsize) (in-highspeed-saw ?b - board ?m - highspeed-saw) (empty ?m - highspeed-saw) (has-colour ?machine - machine ?colour - acolour) (contains-part ?b - board ?p - part) (grind-treatment-change ?old ?new - treatmentstatus) (is-smooth ?surface - surface)) ",
            "input": "",
            "output": ""
        },
        { // termes
            "domain": "(:types numb - object position - object ) (:predicates (height ?p - position ?h - numb) (at ?p - position) (has-block) ; ; static predicates (SUCC ?n1 - numb ?n2 - numb) (NEIGHBOR ?p1 - position ?p2 - position) (IS-DEPOT ?p - position) ) ",
            "input": "",
            "output": ""
        },
        { // paint-nurikabe
            "domain": "(:types cell num group - object) (:predicates (NEXT ?n1 - num ?n2 - num) (CONNECTED ?c - cell ?c2 - cell) ; Defines the graph structure (SOURCE ?x - cell ?g - group) ; The initial position from which the robot must start painting (painted ?r - cell) ; Whether a tile has been painted (available ?x - cell) ; A cell does not belong to any group (part-of ?x - cell ?y - group) ; Whether a cell \"belongs to\" a group. This happens when an adjacent cell belongs to such group (blocked ?x - cell) ; A cell belongs to two different groups so it cannot be painted of any color (remaining-cells ?x - group ?y - num) ; How many tiles remain to be painted for every group (robot-pos ?x - cell) ; Position of the robot (moving) ; The robot is currently not painting (painting ?g - group) ; The robot is currently painting a group (group-painted ?g - group) ; The robot has painted a group ) ",
            "input": "",
            "output": ""
        },
        { // tetris
            "domain": "(:types one_square two_straight right_l - pieces position ) (:predicates (clear ?xy - position) (connected ?x - position ?y - position ) (at_square ?element - one_square ?xy - position) (at_two ?element - two_straight ?xy - position ?xy2 - position) (at_right_l ?element - right_l ?xy - position ?xy2 - position ?xy3 - position) ) ",
            "input": "",
            "output": ""
        },
        { // floor-tile
            "domain": "(:types robot tile color - object) (:predicates (robot-at ?r - robot ?x - tile) (up ?x - tile ?y - tile) (down ?x - tile ?y - tile) (right ?x - tile ?y - tile) (left ?x - tile ?y - tile) (clear ?x - tile) (painted ?x - tile ?c - color) (robot-has ?r - robot ?c - color) (available-color ?c - color) (free-color ?r - robot)) ",
            "input": "",
            "output": "instance tile_0-1 tile|instance tile_0-2 tile|instance tile_1-1 tile|instance tile_1-2 tile|instance tile_2-1 tile|instance tile_2-2 tile|instance robot1 robot|instance robot2 robot|instance white color|instance black color|predicate robot-at robot1 tile_1-1|predicate robot-has robot1 white|predicate robot-at robot2 tile_0-2|predicate robot-has robot2 black|predicate available-color white|predicate available-color black|predicate clear tile_0-1|predicate clear tile_1-2|predicate clear tile_2-1|predicate clear tile_2-2|predicate up tile_1-1 tile_0-1|predicate up tile_1-2 tile_0-2|predicate up tile_2-1 tile_1-1|predicate up tile_2-2 tile_1-2|predicate down tile_0-1 tile_1-1|predicate down tile_0-2 tile_1-2|predicate down tile_1-1 tile_2-1|predicate down tile_1-2 tile_2-2|predicate right tile_0-2 tile_0-1|predicate right tile_1-2 tile_1-1|predicate right tile_2-2 tile_2-1|predicate left tile_0-1 tile_0-2|predicate left tile_1-1 tile_1-2|predicate left tile_2-1 tile_2-2|goal painted tile_1-1 white|goal painted tile_1-2 black|goal painted tile_2-1 black|goal painted tile_2-2 white|"
        },
        { // matchcellar
            "domain": "(:types match fuse) (:predicates (handfree) (unused ?match - match) (mended ?fuse - fuse) (light ?match - match)) ",
            "input": "",
            "output": ""
        },
        { // gold-miner-typed
            "domain": "(:types LOC) (:predicates (robot-at ?x - LOC) (bomb-at ?x - LOC ) (laser-at ?x - LOC) (soft-rock-at ?x - LOC) (hard-rock-at ?x - LOC) (gold-at ?x - LOC) (arm-empty) (holds-bomb) (holds-laser) (holds-gold) (clear ?x - LOC) (connected ?x - LOC ?y - LOC) ) ",
            "input": "",
            "output": "instance f0-0f LOC|instance f0-1f LOC|instancef1-0f LOC|instance f1-1f LOC|predicate arm-empty|predicate connected f0-0f f0-1f|predicate connected f1-0f f1-1f|predicate connected f0-0f f1-0f|predicate connected f0-1f f1-1f|predicate connected f0-1f f0-0f|predicate connected f1-1f f1-0f|predicate connected f1-0f f0-0f|predicate connected f1-1f f0-1f|predicate bomb-at f0-0f|predicate laser-at f0-0f|predicate clear f0-0f|predicate gold-at f0-1f|predicate soft-rock-at f0-1f|predicate robot-at f1-0f|predicate clear f1-0f|predicate hard-rock-at f1-1f|goal holds-gold|"
        },
        { // tidybot
            "domain": "(:types robot cart object xc yc xrel yrel) (:predicates ;; Constant preds (leftof ?x1 - xc ?x2 - xc) (above ?y1 - yc ?y2 - yc) (leftof-rel ?x1 - xrel ?x2 - xrel) (above-rel ?y1 - yrel ?y2 - yrel) (sum-x ?x - xc ?xr - xrel ?xsum - xc) (sum-y ?y - yc ?yr - yrel ?ysum - yc) (zerox-rel ?x - xrel) (zeroy-rel ?y - yrel) (object-goal ?o - object ?x - xc ?y - yc) ;; Robot base (parked ?r - robot) (base-pos ?r - robot ?x - xc ?y - yc) (base-obstacle ?x - xc ?y - yc) ;; Objects (object-pos ?o - object ?x - xc ?y - yc) (object-done ?o - object) (surface ?x - xc ?y - yc) ;; Gripper (holding ?r - robot ?o - object) (gripper-empty ?r - robot) (gripper-rel ?r - robot ?x - xrel ?y - yrel) (gripper-obstacle ?x - xc ?y - yc) ;; Cart (pushing ?r - robot ?c - cart) (not-pushing ?r - robot) (not-pushed ?c - cart) (cart-pos ?c - cart ?x - xc ?y - yc) (on-cart ?o - object ?c - cart) ) ",
            "input": "",
            "output": ""
        },
        { // mprime-strips
            "domain": "(:types location space fuel locatable - object vehicle cargo - locatable) (:predicates (at ?o - locatable ?l - location) (conn ?l1 ?l2 - location) (has-fuel ?l - location ?f - fuel) (fuel-neighbor ?f1 ?f2 - fuel) (in ?c - cargo ?v - vehicle) (has-space ?v - vehicle ?s - space) (space-neighbor ?s1 ?s2 - space) (not-equal ?l1 ?l2 - location) ) ",
            "input": "",
            "output": ""
        },
        { // barman
            "domain": "(:types hand level beverage dispenser container - object ingredient cocktail - beverage shot shaker - container) (:predicates (ontable ?c - container) (holding ?h - hand ?c - container) (handempty ?h - hand) (empty ?c - container) (contains ?c - container ?b - beverage) (clean ?c - container) (used ?c - container ?b - beverage) (dispenses ?d - dispenser ?i - ingredient) (shaker-empty-level ?s - shaker ?l - level) (shaker-level ?s - shaker ?l - level) (next ?l1 ?l2 - level) (unshaked ?s - shaker) (shaked ?s - shaker) (cocktail-part1 ?c - cocktail ?i - ingredient) (cocktail-part2 ?c - cocktail ?i - ingredient)) ",
            "input": "You have two empty hands. On the table in front of you, you have one clean and empty shaker and two clean and empty shots. The two dispenser dispenses two different ingredients. Please make me a cocktail with one of the shots.",
            "output": "instance shaker1 shaker|instance left hand|instance right hand|instance shot1|instance shot2 shot|instance ingredient1 ingredient|instance ingredient2 ingredient|instance cocktail1 cocktail|instance cocktail2 cocktail|instance dispenser1 dispenser|instance dispenser2 dispenser|instance l0 level|instance l1 level|instance l2 level|predicate ontable shaker1|predicate ontable shot1|predicate ontable shot2|predicate dispenses dispenser1 ingredient1|predicate dispenses dispenser2 ingredient2|predicate clean shaker1|predicate clean shot1|predicate clean shot2|predicate empty shaker1|predicate empty shot1|predicate empty shot2|predicate handempty left|predicate handempty right|predicate shaker-empty-level shaker1 l0|predicate shaker-level shaker1 l0|predicate next l0 l1|predicate l1 l2|predicate cocktail-part1 cocktail1 ingredient1|predicate cocktail-part2 cocktail1 ingredient2|goal contains shot1 cocktail1|"
        },
        { // grippers-strips
            "domain": "(:types room object robot gripper) (:predicates (at-robby ?r - robot ?x - room) (at ?o - object ?x - room) (free ?r - robot ?g - gripper) (carry ?r - robot ?o - object ?g - gripper)) ",
            "input": "",
            "output": "instance robot1 robot|instance rgripper1 gripper|instance lgripper1 gripper|instance room1 room|instance room2 room|instance room3 room|instance ball1 object|instance ball2 object|predicate at-robby robot1 room2|predicate free robot1 rgripper1|predicate free robot1 lgripper1|predicate at ball1 room1|predicate at ball2 room2|goal at ball1 room2|goal at ball2 room3|"
        },
        { // cave-diving-adl
            "domain": "(:types location diver tank quantity) (:predicates (at-tank ?t - tank ?l - location) (in-storage ?t - tank) (full ?t - tank) (next-tank ?t1 - tank ?t2 - tank) (at-diver ?d - diver ?l - location) (available ?d - diver) (at-surface ?d - diver) (decompressing ?d - diver) (precludes ?d1 - diver ?d2 - diver) (cave-entrance ?l - location) (connected ?l1 - location ?l2 - location) (next-quantity ?q1 - quantity ?q2 - quantity) (holding ?d - diver ?t - tank) (capacity ?d - diver ?q - quantity) (have-photo ?l - location) (in-water ) ) ",
            "input": "Organize a cave diving expedition to photograph objectives in locations l3 and l4. Start by hiring divers who can work together without issues, considering their hiring costs and air tank capacities. Prepare and strategically place air tanks through the cave system for the divers to use. Ensure all divers decompress after their single trip into the cave. Achieve the goals with minimal total cost. There are five locations, six divers, 24 tanks including a dummy tank and five qunatity levels. Initially, all tanks are available and at max capacity. Next tanks are ordered, cave entrance is at the first location and all caves are connected in series. The tank quantities goes from increasing/decreasing. You can decide how the divers preclude and also all the costs. The goal is to have a photo at location 2 and 3 and all divers decompressed.",
            "output": "instance l0 location|instance l1 location|instance l2 location|instance l3 location|instance l4 location|instance d0 diver|instance d1 diver|instance d2 diver|instance d3 diver|instance d4 diver|instance d5 diver|instance t0 tank|instance t1 tank|instance t2 tank|instance t3 tank|instance t4 tank|instance t5 tank|instance t6 tank|instance t7 tank|instance t8 tank|instance t9 tank|instance t10 tank|instance t11 tank|instance t12 tank|instance t13 tank|instance t14 tank|instance t15 tank|instance t16 tank|instance t17 tank|instance t18 tank|instance t19 tank|instance t20 tank|instance t21 tank|instance t22 tank|instance dummy tank|instance zero quantity|instance one quantity|instance two quantity|instance three quantity|instance four quantity|predicate available d0|predicate available d1|predicate available d2|predicate available d3|predicate available d4|predicate available d5|predicate capacity d0 four|predicate capacity d1 four|predicate capacity d2 four|predicate capacity d3 four|predicate capacity d4 four|predicate capacity d5 four|predicate in-storage t0|predicate next-tank t0 t1|predicate next-tank t1 t2|predicate next-tank t2 t3|predicate next-tank t3 t4|predicate next-tank t4 t5|predicate next-tank t5 t6|predicate next-tank t6 t7|predicate next-tank t7 t8|predicate next-tank t8 t9|predicate next-tank t9 t10|predicate next-tank t10 t11|predicate next-tank t11 t12|predicate next-tank t12 t13|predicate next-tank t13 t14|predicate next-tank t14 t15|predicate next-tank t15 t16|predicate next-tank t16 t17|predicate next-tank t17 t18|predicate next-tank t18 t19|predicate next-tank t19 t20|predicate next-tank t20 t21|predicate next-tank t21 t22|predicate next-tank t22 dummy|predicate cave-entrance l0|predicate connected l0 l1|predicate connected l1 l0|predicate connected l1 l2|predicate connected l2 l1|predicate connected l2 l3|predicate connected l3 l2|predicate connected l1 l4|predicate connected l4 l1|predicate next-quantity zero one|predicate next-quantity one two|predicate next-quantity two three|predicate next-quantity three four|predicate precludes d2 d3|predicate precludes d2 d5|predicate precludes d0 d1|predicate precludes d3 d5|predicate precludes d3 d4|predicate precludes d5 d1|cost hiring d0 43|cost hiring d1 71|cost hiring d2 10|cost hiring d3 10|cost hiring d4 74|cost hiring d5 40|cost other 1|cost total-cost 0|goal have-photo l3|goal have-photo l4|goal decompressing d0|goal decompressing d1|goal decompressing d2|goal decompressing d3|goal decompressing d4|goal decompressing d5|"
        },
    ]
}